{"version":3,"sources":["containers/LoginEmployeesPage/constants.js","containers/LoginEmployeesPage/reducer.js","containers/LoginEmployeesPage/selectors.js","containers/LoginEmployeesPage/saga.js","containers/LoginEmployeesPage/actions.js","containers/LoginEmployeesPage/index.js","utils/checkStore.js","utils/serverURL.js","utils/reducerInjectors.js","utils/injectReducer.js","utils/request.js","utils/constants.js","utils/sagaInjectors.js","utils/injectSaga.js"],"names":["CHANGE_CODE","CHECK_CREDENTIALS","CREATE_SESSION","initialState","code","wasAccepted","employee","LoginEmployeesReducer","state","action","produce","draft","type","owner","selectLoginE","loginEmployees","makeSelectCode","createSelector","loginState","checkCredentialsSaga","sagaListener","require","select","requestURL","getServerUrl","call","request","headers","method","response","length","localStorage","setItem","JSON","stringify","console","log","put","takeLatest","key","LoginEmployeesPage","onChangeCode","checkCredentials","useInjectReducer","reducer","useInjectSaga","saga","className","to","style","marginTop","htmlFor","value","onChange","placeholder","width","onClick","mapStateToProps","createStructuredSelector","mapDispatchToProps","dispatch","evt","target","email","withConnect","connect","compose","memo","checkStore","store","injectReducerFactory","isValid","invariant","isString","isEmpty","isFunction","Reflect","has","injectedReducers","replaceReducer","createReducer","getInjectors","injectReducer","context","React","useContext","ReactReduxContext","useEffect","parseJSON","status","json","checkStatus","error","Error","statusText","url","options","fetch","then","DAEMON","ONCE_TILL_UNMOUNT","checkKey","injectSagaFactory","descriptor","args","newDescriptor","mode","hasSaga","injectedSagas","task","runSaga","ejectSagaFactory","cancel","injectSaga","ejectSaga","injectors"],"mappings":"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","file":"static/js/10.1a8cad11.chunk.js","sourcesContent":["/*\n * LoginEmployeesPage Constants\n * Each action has a corresponding type, which the reducer knows and picks up on.\n * To avoid weird typos between the reducer and the actions, we save them as\n * constants here. We prefix them with 'yourproject/YourComponent' so we avoid\n * reducers accidentally picking up actions they shouldn't.\n *\n * Follow this format:\n * export const YOUR_ACTION_CONSTANT = 'yourproject/YourContainer/YOUR_ACTION_CONSTANT';\n */\n\nexport const CHANGE_CODE = 'ps/LoginEmployeesPage/CHANGE_CODE';\nexport const CHECK_CREDENTIALS = 'ps/LoginEmployeesPage/CHECK_CREDENTIALS';\nexport const CREATE_SESSION = 'ps/LoginEmployeesPage/CREATE_SESSION';","/*\n * LoginEmployees Reducer\n *\n * The reducer takes care of our data. Using actions, we can\n * update our application state. To add a new action,\n * add it to the switch statement in the reducer function\n *\n */\n\nimport produce from 'immer';\nimport { CHANGE_CODE, CREATE_SESSION, CHECK_CREDENTIALS } from './constants';\n\n// The initial state of the App\nexport const initialState = {\n  code: '',\n  wasAccepted: false,\n  employee: {},\n};\n\n/* eslint-disable default-case, no-param-reassign */\nconst LoginEmployeesReducer = (state = initialState, action) =>\n  produce(state, draft => {\n    switch (action.type) {\n      case CHANGE_CODE:\n        draft.code = action.code;\n        break;\n      case CHECK_CREDENTIALS:\n        break;\n      case CREATE_SESSION:\n        draft.wasAccepted = true;\n        draft.owner = action.owner;\n        break;\n    }\n  });\n\nexport default LoginEmployeesReducer;","/**\n * LoginPage selectors\n */\n\nimport { createSelector } from 'reselect';\nimport { initialState } from './reducer';\n\nconst selectLoginE = state => state.loginEmployees || initialState;\n\nconst makeSelectCode = () =>\n  createSelector(\n    selectLoginE,\n    loginState => loginState.code,\n  );\n\nconst makeSelectWasAccepted = () =>\n  createSelector(\n    selectLoginE,\n    loginState => loginState.wasAccepted,\n  );\n\nexport { makeSelectCode, makeSelectWasAccepted };","/**\n * Gets the repositories of the user from Github\n */\nimport { getServerUrl } from './../../utils/serverURL';\nimport { call, put, select, takeLatest } from 'redux-saga/effects';\nimport { CHECK_CREDENTIALS } from './constants';\nimport { createSession, checkCredentials } from './actions';\nimport { makeSelectCode } from './selectors';\nimport request from './../../utils/request';\n/**\n * THIS CANT BE HERE \n */\nconst crypto = require('crypto');\n\n/**\n * \n */\nexport function* checkCredentialsSaga() {\n  // Select username from store\n  const code = yield select(makeSelectCode());\n  const requestURL = `${getServerUrl()}/employees_auth?_id=${code}`;\n\n  try {\n    const response = yield call(request, requestURL, {\n      headers: {'Content-Type': 'application/json'},\n      method: 'GET'\n    });\n\n    if(response.length > 0) {\n      localStorage.setItem('employee', JSON.stringify(response[0]));\n      console.log(response)\n      yield put(createSession(response));\n    }\n\n  } catch (err) {\n    console.log(\"err\")\n    console.log(err)\n  }\n}\n\n/**\n * Root saga manages watcher lifecycle\n */\nexport default function* sagaListener() {\n  yield takeLatest(CHECK_CREDENTIALS, checkCredentialsSaga);\n}","\n\nimport { CHANGE_CODE, CHECK_CREDENTIALS, CREATE_SESSION } from './constants';\n\n/**\n * Changes the input field of the form\n *\n * @param  {string} code The new text of the input field\n *\n * @return {object} An action object with a type of CHANGE_USERNAME\n */\nexport function changeCode(code) {\n  return {\n    type: CHANGE_CODE,\n    code,\n  };\n}\n\nexport function checkCredentials(code) {\n  return {\n    type: CHECK_CREDENTIALS,\n    code,\n  };\n}\n\nexport function createSession(employee){\n  return {\n    type: CREATE_SESSION,\n    employee,\n  };\n}","import React, { useEffect, memo } from 'react'\nimport PropTypes from 'prop-types';\nimport { Redirect } from 'react-router';\n\nimport { connect } from 'react-redux';\nimport { compose } from 'redux';\nimport { createStructuredSelector } from 'reselect';\n\nimport { useInjectReducer } from './../../utils/injectReducer';\nimport { useInjectSaga } from './../../utils/injectSaga';\n\nimport { changeCode, checkCredentials } from './actions';\n\nimport { makeSelectCode, makeSelectWasAccepted } from './selectors';\n\nimport reducer from './reducer';\nimport saga from './saga';\n\nconst key = 'loginEmployees';\n\nexport function LoginEmployeesPage({\ncode, \nwasAccepted,\nonChangeCode,\ncheckCredentials\n}) {\n\n  useInjectReducer({ key, reducer });\n  useInjectSaga({ key, saga });\n  \n  return (\n    <div className=\"row justify-content-center\">\n      {wasAccepted ? <Redirect to=\"/buy_process\" /> : null }\n      <div className=\"col-4\" style={{marginTop:'calc(50vh - 160px)'}}>\n        <div className=\"card\">\n          <div className=\"card-body\">\n            <div className=\"form-group\">\n              <label htmlFor=\"exampleInputEmail1\">INGRESAR CÓDIGO</label>\n              <input type=\"password\" className=\"form-control\" value={code} onChange={onChangeCode} placeholder=\"Ingresar Código\"/>\n              <small className=\"form-text text-muted\">Tu código es personal, no lo compartas con nadie.</small>\n            </div>\n          </div>\n        </div>          \n        <div className=\"btn btn-dark\" style={{marginTop:'24px', width:'160px'}} onClick={() => checkCredentials(code)}>Ingresar</div>\n      </div>\n    </div>\n  )\n}\n\nLoginEmployeesPage.propTypes = {\n  code: PropTypes.string,\n};\n\nconst mapStateToProps = createStructuredSelector({\n  code: makeSelectCode(),\n  wasAccepted: makeSelectWasAccepted(),\n});\n\nexport function mapDispatchToProps(dispatch) {\n  return {\n    onChangeCode: (evt) => dispatch(changeCode(evt.target.value)),\n    checkCredentials: (code, email) => {\n      dispatch(checkCredentials(code, email))\n    },\n  };\n}\n\nconst withConnect = connect(\n  mapStateToProps,\n  mapDispatchToProps,\n);\n\n\nexport default compose(\n  withConnect,\n  memo,\n)(LoginEmployeesPage);\n","/**\n * Validate the shape of redux store\n */\nexport default function checkStore(store) {\n  return true;\n}","const getServerUrl = () => {\n  return \"https://5ec3621d.ngrok.io\";\n}\n\nexport { getServerUrl };","import invariant from 'invariant';\nimport { isEmpty, isFunction, isString } from 'lodash';\n\nimport checkStore from './checkStore';\nimport createReducer from './../reducers';\n\nexport function injectReducerFactory(store, isValid) {\n  return function injectReducer(key, reducer) {\n    if (!isValid) checkStore(store);\n\n    invariant(\n      isString(key) && !isEmpty(key) && isFunction(reducer),\n      '(src/utils...) injectReducer: Expected `reducer` to be a reducer function',\n    );\n\n    // Check `store.injectedReducers[key] === reducer` for hot reloading when a key is the same but a reducer is different\n    if (\n      Reflect.has(store.injectedReducers, key) &&\n      store.injectedReducers[key] === reducer\n    )\n      return;\n\n    store.injectedReducers[key] = reducer; // eslint-disable-line no-param-reassign\n    store.replaceReducer(createReducer(store.injectedReducers));\n  };\n}\n\nexport default function getInjectors(store) {\n  checkStore(store);\n\n  return {\n    injectReducer: injectReducerFactory(store, true),\n  };\n}","import React from 'react';\nimport hoistNonReactStatics from 'hoist-non-react-statics';\nimport { ReactReduxContext } from 'react-redux';\n\nimport getInjectors from './reducerInjectors';\n\n/**\n * Dynamically injects a reducer\n *\n * @param {string} key A key of the reducer\n * @param {function} reducer A reducer that will be injected\n *\n */\nexport default ({ key, reducer }) => WrappedComponent => {\n  class ReducerInjector extends React.Component {\n    static WrappedComponent = WrappedComponent;\n\n    static contextType = ReactReduxContext;\n\n    static displayName = `withReducer(${WrappedComponent.displayName ||\n      WrappedComponent.name ||\n      'Component'})`;\n\n    constructor(props, context) {\n      super(props, context);\n\n      getInjectors(context.store).injectReducer(key, reducer);\n    }\n\n    render() {\n      return <WrappedComponent {...this.props} />;\n    }\n  }\n\n  return hoistNonReactStatics(ReducerInjector, WrappedComponent);\n};\n\nconst useInjectReducer = ({ key, reducer }) => {\n  const context = React.useContext(ReactReduxContext);\n  React.useEffect(() => {\n    getInjectors(context.store).injectReducer(key, reducer);\n  }, []);\n};\n\nexport { useInjectReducer };","/**\n * Parses the JSON returned by a network request\n *\n * @param  {object} response A response from a network request\n *\n * @return {object}          The parsed JSON from the request\n */\nfunction parseJSON(response) {\n  if (response.status === 204 || response.status === 205) {\n    return null;\n  }\n  return response.json();\n}\n\n/**\n * Checks if a network request came back fine, and throws an error if not\n *\n * @param  {object} response   A response from a network request\n *\n * @return {object|undefined} Returns either the response, or throws an error\n */\nfunction checkStatus(response) {\n  if (response.status >= 200 && response.status < 300) {\n    return response;\n  }\n\n  const error = new Error(response.statusText);\n  error.response = response;\n  throw error;\n}\n\n/**\n * Requests a URL, returning a promise\n *\n * @param  {string} url       The URL we want to request\n * @param  {object} [options] The options we want to pass to \"fetch\"\n *\n * @return {object}           The response data\n */\nexport default function request(url, options) {\n  return fetch(url, options)\n    .then(checkStatus)\n    .then(parseJSON);\n}","export const RESTART_ON_REMOUNT = '@@saga-injector/restart-on-remount';\nexport const DAEMON = '@@saga-injector/daemon';\nexport const ONCE_TILL_UNMOUNT = '@@saga-injector/once-till-unmount';","import invariant from 'invariant';\nimport { isEmpty, isFunction, isString, conformsTo } from 'lodash';\n\nimport checkStore from './checkStore';\nimport { DAEMON, ONCE_TILL_UNMOUNT, RESTART_ON_REMOUNT } from './constants';\n\nconst allowedModes = [RESTART_ON_REMOUNT, DAEMON, ONCE_TILL_UNMOUNT];\n\nconst checkKey = key =>\n  invariant(\n    isString(key) && !isEmpty(key),\n    '(app/utils...) injectSaga: Expected `key` to be a non empty string',\n  );\n\nconst checkDescriptor = descriptor => {\n  const shape = {\n    saga: isFunction,\n    mode: mode => isString(mode) && allowedModes.includes(mode),\n  };\n  invariant(\n    conformsTo(descriptor, shape),\n    '(src/utils...) injectSaga: Expected a valid saga descriptor',\n  );\n};\n\nexport function injectSagaFactory(store, isValid) {\n  return function injectSaga(key, descriptor = {}, args) {\n    if (!isValid) checkStore(store);\n\n    const newDescriptor = {\n      ...descriptor,\n      mode: descriptor.mode || DAEMON,\n    };\n    const { saga, mode } = newDescriptor;\n\n    checkKey(key);\n    //checkDescriptor(newDescriptor);\n\n    let hasSaga = Reflect.has(store.injectedSagas, key);\n\n    if (process.env.NODE_ENV !== 'production') {\n      const oldDescriptor = store.injectedSagas[key];\n      // enable hot reloading of daemon and once-till-unmount sagas\n      if (hasSaga && oldDescriptor.saga !== saga) {\n        oldDescriptor.task.cancel();\n        hasSaga = false;\n      }\n    }\n\n    if (\n      !hasSaga ||\n      (hasSaga && mode !== DAEMON && mode !== ONCE_TILL_UNMOUNT)\n    ) {\n      /* eslint-disable no-param-reassign */\n      store.injectedSagas[key] = {\n        ...newDescriptor,\n        task: store.runSaga(saga, args),\n      };\n      /* eslint-enable no-param-reassign */\n    }\n  };\n}\n\nexport function ejectSagaFactory(store, isValid) {\n  return function ejectSaga(key) {\n    if (!isValid) checkStore(store);\n\n    checkKey(key);\n\n    if (Reflect.has(store.injectedSagas, key)) {\n      const descriptor = store.injectedSagas[key];\n      if (descriptor.mode && descriptor.mode !== DAEMON) {\n        descriptor.task.cancel();\n        // Clean up in production; in development we need `descriptor.saga` for hot reloading\n        if (process.env.NODE_ENV === 'production') {\n          // Need some value to be able to detect `ONCE_TILL_UNMOUNT` sagas in `injectSaga`\n          store.injectedSagas[key] = 'done'; // eslint-disable-line no-param-reassign\n        }\n      }\n    }\n  };\n}\n\nexport default function getInjectors(store) {\n  checkStore(store);\n\n  return {\n    injectSaga: injectSagaFactory(store, true),\n    ejectSaga: ejectSagaFactory(store, true),\n  };\n}\n","import React from 'react';\nimport hoistNonReactStatics from 'hoist-non-react-statics';\nimport { ReactReduxContext } from 'react-redux';\n\nimport getInjectors from './sagaInjectors';\n\n/**\n * Dynamically injects a saga, passes component's props as saga arguments\n *\n * @param {string} key A key of the saga\n * @param {function} saga A root saga that will be injected\n * @param {string} [mode] By default (constants.DAEMON) the saga will be started\n * on component mount and never canceled or started again. Another two options:\n *   - constants.RESTART_ON_REMOUNT — the saga will be started on component mount and\n *   cancelled with `task.cancel()` on component unmount for improved performance,\n *   - constants.ONCE_TILL_UNMOUNT — behaves like 'RESTART_ON_REMOUNT' but never runs it again.\n *\n */\nexport default ({ key, saga, mode }) => WrappedComponent => {\n  class InjectSaga extends React.Component {\n    static WrappedComponent = WrappedComponent;\n\n    static contextType = ReactReduxContext;\n\n    static displayName = `withSaga(${WrappedComponent.displayName ||\n      WrappedComponent.name ||\n      'Component'})`;\n\n    constructor(props, context) {\n      super(props, context);\n\n      this.injectors = getInjectors(context.store);\n\n      this.injectors.injectSaga(key, { saga, mode }, this.props);\n    }\n\n    componentWillUnmount() {\n      this.injectors.ejectSaga(key);\n    }\n\n    render() {\n      return <WrappedComponent {...this.props} />;\n    }\n  }\n\n  return hoistNonReactStatics(InjectSaga, WrappedComponent);\n};\n\nconst useInjectSaga = ({ key, saga, mode }) => {\n  const context = React.useContext(ReactReduxContext);\n  React.useEffect(() => {\n    const injectors = getInjectors(context.store);\n    injectors.injectSaga(key, { saga, mode });\n\n    return () => {\n      injectors.ejectSaga(key);\n    };\n  }, []);\n};\n\nexport { useInjectSaga };"],"sourceRoot":""}