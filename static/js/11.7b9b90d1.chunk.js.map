{"version":3,"sources":["containers/LoginPage/constants.js","containers/LoginPage/reducer.js","containers/LoginPage/selectors.js","containers/LoginPage/saga.js","containers/LoginPage/actions.js","containers/LoginPage/index.js","utils/checkStore.js","utils/serverURL.js","utils/reducerInjectors.js","utils/injectReducer.js","utils/request.js","utils/constants.js","utils/sagaInjectors.js","utils/injectSaga.js"],"names":["CHANGE_CODE","CHANGE_EMAIL","CHECK_CREDENTIALS","CREATE_SESSION","initialState","code","email","wasAccepted","owner","loginReducer","state","action","produce","draft","type","selectLogin","login","makeSelectCode","createSelector","loginState","makeSelectEmail","checkCredentialsSaga","sagaListener","require","select","requestURL","getServerUrl","call","request","body","JSON","stringify","strategy","headers","method","authResponse","localStorage","setItem","accessToken","console","log","put","user","takeLatest","key","LoginPage","onChangeCode","onChangeEmail","checkCredentials","useInjectReducer","reducer","useInjectSaga","saga","className","to","style","marginTop","htmlFor","value","onChange","placeholder","width","onClick","mapStateToProps","createStructuredSelector","mapDispatchToProps","dispatch","evt","target","withConnect","connect","compose","memo","checkStore","store","injectReducerFactory","isValid","invariant","isString","isEmpty","isFunction","Reflect","has","injectedReducers","replaceReducer","createReducer","getInjectors","injectReducer","context","React","useContext","ReactReduxContext","useEffect","parseJSON","response","status","json","checkStatus","error","Error","statusText","url","options","fetch","then","DAEMON","ONCE_TILL_UNMOUNT","checkKey","injectSagaFactory","descriptor","args","newDescriptor","mode","hasSaga","injectedSagas","task","runSaga","ejectSagaFactory","cancel","injectSaga","ejectSaga","injectors"],"mappings":"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","file":"static/js/11.7b9b90d1.chunk.js","sourcesContent":["/*\n * LoginConstants\n * Each action has a corresponding type, which the reducer knows and picks up on.\n * To avoid weird typos between the reducer and the actions, we save them as\n * constants here. We prefix them with 'yourproject/YourComponent' so we avoid\n * reducers accidentally picking up actions they shouldn't.\n *\n * Follow this format:\n * export const YOUR_ACTION_CONSTANT = 'yourproject/YourContainer/YOUR_ACTION_CONSTANT';\n */\n\nexport const CHANGE_CODE = 'ps/LoginPage/CHANGE_CODE';\nexport const CHANGE_EMAIL = 'ps/LoginPage/CHANGE_EMAIL';\nexport const CHECK_CREDENTIALS = 'ps/LoginPage/CHECK_CREDENTIALS';\nexport const CREATE_SESSION = 'ps/LoginPage/CREATE_SESSION';","/*\n * LoginReducer\n *\n * The reducer takes care of our data. Using actions, we can\n * update our application state. To add a new action,\n * add it to the switch statement in the reducer function\n *\n */\n\nimport produce from 'immer';\nimport { CHANGE_CODE, CHANGE_EMAIL, CREATE_SESSION, CHECK_CREDENTIALS } from './constants';\n\n// The initial state of the App\nexport const initialState = {\n  code: '',\n  email: '',\n  wasAccepted: false,\n  owner: {},\n};\n\n/* eslint-disable default-case, no-param-reassign */\nconst loginReducer = (state = initialState, action) =>\n  produce(state, draft => {\n    switch (action.type) {\n      case CHANGE_CODE:\n        draft.code = action.code;\n        break;\n      case CHANGE_EMAIL:\n        draft.email = action.email;\n        break;\n      case CREATE_SESSION:\n        draft.wasAccepted = true;\n        draft.owner = action.owner;\n        break;\n      case CHECK_CREDENTIALS:\n        break;\n    }\n  });\n\nexport default loginReducer;","/**\n * LoginPage selectors\n */\n\nimport { createSelector } from 'reselect';\nimport { initialState } from './reducer';\n\nconst selectLogin = state => state.login || initialState;\n\nconst makeSelectCode = () =>\n  createSelector(\n    selectLogin,\n    loginState => loginState.code,\n  );\n\nconst makeSelectEmail = () =>\n  createSelector(\n    selectLogin,\n    loginState => loginState.email,\n  );\n\nconst makeSelectWasAccepted = () =>\n  createSelector(\n    selectLogin,\n    loginState => loginState.wasAccepted,\n  );\n\nexport { makeSelectCode, makeSelectEmail, makeSelectWasAccepted };","/**\n * Gets the repositories of the user from Github\n */\nimport { getServerUrl } from './../../utils/serverURL';\nimport { call, put, select, takeLatest } from 'redux-saga/effects';\nimport { CHECK_CREDENTIALS } from './constants';\nimport { createSession, checkCredentials } from './actions';\nimport { makeSelectCode, makeSelectEmail } from './selectors';\nimport request from './../../utils/request';\n/**\n * THIS CANT BE HERE \n */\nconst crypto = require('crypto');\n\n/**\n * \n */\nexport function* checkCredentialsSaga() {\n  // Select username from store\n  const code = yield select(makeSelectCode());\n  const email = yield select(makeSelectEmail());\n  const requestURL = `${getServerUrl()}/authentication`;\n\n  try {\n    const authResponse = yield call(request, requestURL, {\n      body: JSON.stringify({code:code, email: email, strategy: \"local\"}),\n      headers: {'Content-Type': 'application/json'},\n      method: 'POST'\n    });\n\n    localStorage.setItem('PointOfSaleToken', authResponse.accessToken);\n    console.log(authResponse)\n    yield put(createSession(authResponse.user));\n\n  } catch (err) {\n    console.log(\"err\")\n    console.log(err)\n  }\n}\n\n/**\n * Root saga manages watcher lifecycle\n */\nexport default function* sagaListener() {\n  yield takeLatest(CHECK_CREDENTIALS, checkCredentialsSaga);\n}","/*\n * Login Actions\n *\n * Actions change things in your application\n * Since this boilerplate uses a uni-directional data flow, specifically redux,\n * we have these actions which are the only way your application interacts with\n * your application state. This guarantees that your state is up to date and nobody\n * messes it up weirdly somewhere.\n *\n * To add a new Action:\n * 1) Import your constant\n * 2) Add a function like this:\n *    export function yourAction(var) {\n *        return { type: YOUR_ACTION_CONSTANT, var: var }\n *    }\n */\n\nimport { CHANGE_CODE, CHANGE_EMAIL, CHECK_CREDENTIALS, CREATE_SESSION } from './constants';\n\n/**\n * Changes the input field of the form\n *\n * @param  {string} code The new text of the input field\n * @param  {string} email The new text of the input field\n * @param  {boolean} wasAccepted The new text of the input field\n *\n * @return {object} An action object with a type of CHANGE_USERNAME\n */\nexport function changeCode(code) {\n  return {\n    type: CHANGE_CODE,\n    code,\n  };\n}\n\nexport function changeEmail(email) {\n  return {\n    type: CHANGE_EMAIL,\n    email,\n  };\n}\n\nexport function checkCredentials(code) {\n  console.log(\"action\");\n  return {\n    type: CHECK_CREDENTIALS,\n    code,\n  };\n}\n\nexport function createSession(owner){\n  return {\n    type: CREATE_SESSION,\n    owner,\n  };\n}","import React, { useEffect, memo } from 'react'\nimport PropTypes from 'prop-types';\nimport { Redirect } from 'react-router';\n\nimport { connect } from 'react-redux';\nimport { compose } from 'redux';\nimport { createStructuredSelector } from 'reselect';\n\nimport { useInjectReducer } from './../../utils/injectReducer';\nimport { useInjectSaga } from './../../utils/injectSaga';\n\nimport { changeCode, changeEmail, checkCredentials } from './actions';\n\nimport { makeSelectCode, makeSelectEmail, makeSelectWasAccepted } from './selectors';\n\nimport reducer from './reducer';\nimport saga from './saga';\n\nconst key = 'login';\n\nexport function LoginPage({\ncode, \nemail,\nwasAccepted,\nonChangeCode,\nonChangeEmail,\ncheckCredentials\n}) {\n\n  useInjectReducer({ key, reducer });\n  useInjectSaga({ key, saga });\n  \n  return (\n    <div className=\"row justify-content-center\">\n      {wasAccepted ? <Redirect to=\"/dashboard\" /> : null }\n      <div className=\"col-4\" style={{marginTop:'calc(50vh - 160px)'}}>\n        <div className=\"card\">\n          <div className=\"card-body\">\n            <div className=\"form-group\">\n              <label htmlFor=\"exampleInputEmail1\">INGRESAR CORREO ELECTRÓNICO</label>\n              <input type=\"email\" className=\"form-control\" value={email} onChange={onChangeEmail} placeholder=\"Ingresar correo electrónico\"/>\n            </div>\n            <div className=\"form-group\">\n              <label htmlFor=\"exampleInputEmail1\">INGRESAR CÓDIGO</label>\n              <input type=\"password\" className=\"form-control\" value={code} onChange={onChangeCode} placeholder=\"Ingresar Código\"/>\n              <small className=\"form-text text-muted\">Tu código es personal, no lo compartas con nadie.</small>\n            </div>\n          </div>\n        </div>          \n        <div className=\"btn btn-dark\" style={{marginTop:'24px', width:'160px'}} onClick={() => checkCredentials(code, email)}>Ingresar</div>\n      </div>\n    </div>\n  )\n}\n\nLoginPage.propTypes = {\n  code: PropTypes.string,\n  email: PropTypes.string,\n};\n\nconst mapStateToProps = createStructuredSelector({\n  code: makeSelectCode(),\n  email: makeSelectEmail(),\n  wasAccepted: makeSelectWasAccepted(),\n});\n\nexport function mapDispatchToProps(dispatch) {\n  return {\n    onChangeCode: (evt) => dispatch(changeCode(evt.target.value)),\n    onChangeEmail: (evt) => dispatch(changeEmail(evt.target.value)),\n    checkCredentials: (code, email) => {\n      console.log(\"click\")\n      dispatch(checkCredentials(code, email))\n    },\n  };\n}\n\nconst withConnect = connect(\n  mapStateToProps,\n  mapDispatchToProps,\n);\n\n\nexport default compose(\n  withConnect,\n  memo,\n)(LoginPage);\n","/**\n * Validate the shape of redux store\n */\nexport default function checkStore(store) {\n  return true;\n}","const getServerUrl = () => {\n  return \"https://5ec3621d.ngrok.io\";\n}\n\nexport { getServerUrl };","import invariant from 'invariant';\nimport { isEmpty, isFunction, isString } from 'lodash';\n\nimport checkStore from './checkStore';\nimport createReducer from './../reducers';\n\nexport function injectReducerFactory(store, isValid) {\n  return function injectReducer(key, reducer) {\n    if (!isValid) checkStore(store);\n\n    invariant(\n      isString(key) && !isEmpty(key) && isFunction(reducer),\n      '(src/utils...) injectReducer: Expected `reducer` to be a reducer function',\n    );\n\n    // Check `store.injectedReducers[key] === reducer` for hot reloading when a key is the same but a reducer is different\n    if (\n      Reflect.has(store.injectedReducers, key) &&\n      store.injectedReducers[key] === reducer\n    )\n      return;\n\n    store.injectedReducers[key] = reducer; // eslint-disable-line no-param-reassign\n    store.replaceReducer(createReducer(store.injectedReducers));\n  };\n}\n\nexport default function getInjectors(store) {\n  checkStore(store);\n\n  return {\n    injectReducer: injectReducerFactory(store, true),\n  };\n}","import React from 'react';\nimport hoistNonReactStatics from 'hoist-non-react-statics';\nimport { ReactReduxContext } from 'react-redux';\n\nimport getInjectors from './reducerInjectors';\n\n/**\n * Dynamically injects a reducer\n *\n * @param {string} key A key of the reducer\n * @param {function} reducer A reducer that will be injected\n *\n */\nexport default ({ key, reducer }) => WrappedComponent => {\n  class ReducerInjector extends React.Component {\n    static WrappedComponent = WrappedComponent;\n\n    static contextType = ReactReduxContext;\n\n    static displayName = `withReducer(${WrappedComponent.displayName ||\n      WrappedComponent.name ||\n      'Component'})`;\n\n    constructor(props, context) {\n      super(props, context);\n\n      getInjectors(context.store).injectReducer(key, reducer);\n    }\n\n    render() {\n      return <WrappedComponent {...this.props} />;\n    }\n  }\n\n  return hoistNonReactStatics(ReducerInjector, WrappedComponent);\n};\n\nconst useInjectReducer = ({ key, reducer }) => {\n  const context = React.useContext(ReactReduxContext);\n  React.useEffect(() => {\n    getInjectors(context.store).injectReducer(key, reducer);\n  }, []);\n};\n\nexport { useInjectReducer };","/**\n * Parses the JSON returned by a network request\n *\n * @param  {object} response A response from a network request\n *\n * @return {object}          The parsed JSON from the request\n */\nfunction parseJSON(response) {\n  if (response.status === 204 || response.status === 205) {\n    return null;\n  }\n  return response.json();\n}\n\n/**\n * Checks if a network request came back fine, and throws an error if not\n *\n * @param  {object} response   A response from a network request\n *\n * @return {object|undefined} Returns either the response, or throws an error\n */\nfunction checkStatus(response) {\n  if (response.status >= 200 && response.status < 300) {\n    return response;\n  }\n\n  const error = new Error(response.statusText);\n  error.response = response;\n  throw error;\n}\n\n/**\n * Requests a URL, returning a promise\n *\n * @param  {string} url       The URL we want to request\n * @param  {object} [options] The options we want to pass to \"fetch\"\n *\n * @return {object}           The response data\n */\nexport default function request(url, options) {\n  return fetch(url, options)\n    .then(checkStatus)\n    .then(parseJSON);\n}","export const RESTART_ON_REMOUNT = '@@saga-injector/restart-on-remount';\nexport const DAEMON = '@@saga-injector/daemon';\nexport const ONCE_TILL_UNMOUNT = '@@saga-injector/once-till-unmount';","import invariant from 'invariant';\nimport { isEmpty, isFunction, isString, conformsTo } from 'lodash';\n\nimport checkStore from './checkStore';\nimport { DAEMON, ONCE_TILL_UNMOUNT, RESTART_ON_REMOUNT } from './constants';\n\nconst allowedModes = [RESTART_ON_REMOUNT, DAEMON, ONCE_TILL_UNMOUNT];\n\nconst checkKey = key =>\n  invariant(\n    isString(key) && !isEmpty(key),\n    '(app/utils...) injectSaga: Expected `key` to be a non empty string',\n  );\n\nconst checkDescriptor = descriptor => {\n  const shape = {\n    saga: isFunction,\n    mode: mode => isString(mode) && allowedModes.includes(mode),\n  };\n  invariant(\n    conformsTo(descriptor, shape),\n    '(src/utils...) injectSaga: Expected a valid saga descriptor',\n  );\n};\n\nexport function injectSagaFactory(store, isValid) {\n  return function injectSaga(key, descriptor = {}, args) {\n    if (!isValid) checkStore(store);\n\n    const newDescriptor = {\n      ...descriptor,\n      mode: descriptor.mode || DAEMON,\n    };\n    const { saga, mode } = newDescriptor;\n\n    checkKey(key);\n    //checkDescriptor(newDescriptor);\n\n    let hasSaga = Reflect.has(store.injectedSagas, key);\n\n    if (process.env.NODE_ENV !== 'production') {\n      const oldDescriptor = store.injectedSagas[key];\n      // enable hot reloading of daemon and once-till-unmount sagas\n      if (hasSaga && oldDescriptor.saga !== saga) {\n        oldDescriptor.task.cancel();\n        hasSaga = false;\n      }\n    }\n\n    if (\n      !hasSaga ||\n      (hasSaga && mode !== DAEMON && mode !== ONCE_TILL_UNMOUNT)\n    ) {\n      /* eslint-disable no-param-reassign */\n      store.injectedSagas[key] = {\n        ...newDescriptor,\n        task: store.runSaga(saga, args),\n      };\n      /* eslint-enable no-param-reassign */\n    }\n  };\n}\n\nexport function ejectSagaFactory(store, isValid) {\n  return function ejectSaga(key) {\n    if (!isValid) checkStore(store);\n\n    checkKey(key);\n\n    if (Reflect.has(store.injectedSagas, key)) {\n      const descriptor = store.injectedSagas[key];\n      if (descriptor.mode && descriptor.mode !== DAEMON) {\n        descriptor.task.cancel();\n        // Clean up in production; in development we need `descriptor.saga` for hot reloading\n        if (process.env.NODE_ENV === 'production') {\n          // Need some value to be able to detect `ONCE_TILL_UNMOUNT` sagas in `injectSaga`\n          store.injectedSagas[key] = 'done'; // eslint-disable-line no-param-reassign\n        }\n      }\n    }\n  };\n}\n\nexport default function getInjectors(store) {\n  checkStore(store);\n\n  return {\n    injectSaga: injectSagaFactory(store, true),\n    ejectSaga: ejectSagaFactory(store, true),\n  };\n}\n","import React from 'react';\nimport hoistNonReactStatics from 'hoist-non-react-statics';\nimport { ReactReduxContext } from 'react-redux';\n\nimport getInjectors from './sagaInjectors';\n\n/**\n * Dynamically injects a saga, passes component's props as saga arguments\n *\n * @param {string} key A key of the saga\n * @param {function} saga A root saga that will be injected\n * @param {string} [mode] By default (constants.DAEMON) the saga will be started\n * on component mount and never canceled or started again. Another two options:\n *   - constants.RESTART_ON_REMOUNT — the saga will be started on component mount and\n *   cancelled with `task.cancel()` on component unmount for improved performance,\n *   - constants.ONCE_TILL_UNMOUNT — behaves like 'RESTART_ON_REMOUNT' but never runs it again.\n *\n */\nexport default ({ key, saga, mode }) => WrappedComponent => {\n  class InjectSaga extends React.Component {\n    static WrappedComponent = WrappedComponent;\n\n    static contextType = ReactReduxContext;\n\n    static displayName = `withSaga(${WrappedComponent.displayName ||\n      WrappedComponent.name ||\n      'Component'})`;\n\n    constructor(props, context) {\n      super(props, context);\n\n      this.injectors = getInjectors(context.store);\n\n      this.injectors.injectSaga(key, { saga, mode }, this.props);\n    }\n\n    componentWillUnmount() {\n      this.injectors.ejectSaga(key);\n    }\n\n    render() {\n      return <WrappedComponent {...this.props} />;\n    }\n  }\n\n  return hoistNonReactStatics(InjectSaga, WrappedComponent);\n};\n\nconst useInjectSaga = ({ key, saga, mode }) => {\n  const context = React.useContext(ReactReduxContext);\n  React.useEffect(() => {\n    const injectors = getInjectors(context.store);\n    injectors.injectSaga(key, { saga, mode });\n\n    return () => {\n      injectors.ejectSaga(key);\n    };\n  }, []);\n};\n\nexport { useInjectSaga };"],"sourceRoot":""}