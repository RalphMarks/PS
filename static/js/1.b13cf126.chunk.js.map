{"version":3,"sources":["../node_modules/reselect/es/index.js","../node_modules/immer/dist/immer.module.js"],"names":["defaultEqualityCheck","a","b","areArgumentsShallowlyEqual","equalityCheck","prev","next","length","i","getDependencies","funcs","dependencies","Array","isArray","every","dep","dependencyTypes","map","join","Error","createSelector","memoize","_len","arguments","memoizeOptions","_key","_len2","_key2","recomputations","resultFunc","pop","memoizedResultFunc","apply","undefined","concat","selector","params","push","resetRecomputations","createSelectorCreator","func","lastArgs","lastResult","createStructuredSelector","selectors","selectorCreator","objectKeys","Object","keys","key","_len3","values","_key3","reduce","composition","value","index","obj","_typeof","Symbol","iterator","constructor","prototype","classCallCheck","instance","Constructor","TypeError","createClass","defineProperties","target","props","descriptor","enumerable","configurable","writable","defineProperty","protoProps","staticProps","NOTHING","DRAFT_STATE","isDraft","isDraftable","proto","getPrototypeOf","assign","has","shallowCopy","slice","__proto__","create","each","cb","thing","prop","hasOwnProperty","call","is","x","y","generatePatches","state","basePath","patches","inversePatches","base","copy","assigned","minLength","Math","min","path","op","_i","_i2","generateArrayPatches","assignedValue","origValue","generateObjectPatches","descriptors","scopes","currentScope","createDraft","parent","draft","_state","finalizing","get","assertUnrevoked","source","prepareCopy","_get","this","set","modified","markChanged","_set","createPropertyProxy","scope","finalized","revoke","revoked","createHiddenProperty","JSON","stringify","hasObjectChanges","hasArrayChanges","getOwnPropertyDescriptor","legacyProxy","freeze","willFinalize","result","baseDraft","needPatches","forEach","markChangesRecursively","object","markChangesSweep","scopes$1","currentScope$1","createDraft$1","drafts","_ref","Proxy","revocable","arrayTraps","objectTraps","proxy","source$1","ownKeys","Reflect","markChanged$1","deleteProperty","owner","setPrototypeOf","fn","isNaN","parseInt","modernProxy","configDefaults","useProxies","autoFreeze","process","name","onAssign","onDelete","onCopy","immer","Immer","config","setUseProxies","produce","bind","recipe","patchListener","_this","defaultBase","args","_recipe","finalize","isFrozen","finalizeTree","root","_this2","finalizeProperty","inDraft","patch","_i3"],"mappings":"6FAAA,SAASA,EAAqBC,EAAGC,GAC/B,OAAOD,IAAMC,EAGf,SAASC,EAA2BC,EAAeC,EAAMC,GACvD,GAAa,OAATD,GAA0B,OAATC,GAAiBD,EAAKE,SAAWD,EAAKC,OACzD,OAAO,EAMT,IAFA,IAAIA,EAASF,EAAKE,OAETC,EAAI,EAAGA,EAAID,EAAQC,IAC1B,IAAKJ,EAAcC,EAAKG,GAAIF,EAAKE,IAC/B,OAAO,EAIX,OAAO,EAmBT,SAASC,EAAgBC,GACvB,IAAIC,EAAeC,MAAMC,QAAQH,EAAM,IAAMA,EAAM,GAAKA,EAExD,IAAKC,EAAaG,OAAM,SAAUC,GAChC,MAAsB,oBAARA,KACZ,CACF,IAAIC,EAAkBL,EAAaM,KAAI,SAAUF,GAC/C,cAAcA,KACbG,KAAK,MACR,MAAM,IAAIC,MAAM,wGAAgHH,EAAkB,KAGpJ,OAAOL,EAjDT,oEAiGO,IAAIS,EA7CJ,SAA+BC,GACpC,IAAK,IAAIC,EAAOC,UAAUhB,OAAQiB,EAAiBZ,MAAMU,EAAO,EAAIA,EAAO,EAAI,GAAIG,EAAO,EAAGA,EAAOH,EAAMG,IACxGD,EAAeC,EAAO,GAAKF,UAAUE,GAGvC,OAAO,WACL,IAAK,IAAIC,EAAQH,UAAUhB,OAAQG,EAAQE,MAAMc,GAAQC,EAAQ,EAAGA,EAAQD,EAAOC,IACjFjB,EAAMiB,GAASJ,UAAUI,GAG3B,IAAIC,EAAiB,EACjBC,EAAanB,EAAMoB,MACnBnB,EAAeF,EAAgBC,GAC/BqB,EAAqBV,EAAQW,WAAMC,EAAW,CAAC,WAGjD,OAFAL,IAEOC,EAAWG,MAAM,KAAMT,aAC7BW,OAAOV,IAENW,EAAWd,GAAQ,WAIrB,IAHA,IAAIe,EAAS,GACT7B,EAASI,EAAaJ,OAEjBC,EAAI,EAAGA,EAAID,EAAQC,IAE1B4B,EAAOC,KAAK1B,EAAaH,GAAGwB,MAAM,KAAMT,YAI1C,OAAOQ,EAAmBC,MAAM,KAAMI,MAaxC,OAXAD,EAASN,WAAaA,EACtBM,EAASxB,aAAeA,EAExBwB,EAASP,eAAiB,WACxB,OAAOA,GAGTO,EAASG,oBAAsB,WAC7B,OAAOV,EAAiB,GAGnBO,GAGiBI,EA5ErB,SAAwBC,GAC7B,IAAIpC,EAAgBmB,UAAUhB,OAAS,QAAsB0B,IAAjBV,UAAU,GAAmBA,UAAU,GAAKvB,EACpFyC,EAAW,KACXC,EAAa,KAEjB,OAAO,WAOL,OANKvC,EAA2BC,EAAeqC,EAAUlB,aAEvDmB,EAAaF,EAAKR,MAAM,KAAMT,YAGhCkB,EAAWlB,UACJmB,MAiEJ,SAASC,EAAyBC,GACvC,IAAIC,EAAkBtB,UAAUhB,OAAS,QAAsB0B,IAAjBV,UAAU,GAAmBA,UAAU,GAAKH,EAE1F,GAAyB,kBAAdwB,EACT,MAAM,IAAIzB,MAAM,gIAAwIyB,GAG1J,IAAIE,EAAaC,OAAOC,KAAKJ,GAC7B,OAAOC,EAAgBC,EAAW7B,KAAI,SAAUgC,GAC9C,OAAOL,EAAUK,OACf,WACF,IAAK,IAAIC,EAAQ3B,UAAUhB,OAAQ4C,EAASvC,MAAMsC,GAAQE,EAAQ,EAAGA,EAAQF,EAAOE,IAClFD,EAAOC,GAAS7B,UAAU6B,GAG5B,OAAOD,EAAOE,QAAO,SAAUC,EAAaC,EAAOC,GAEjD,OADAF,EAAYR,EAAWU,IAAUD,EAC1BD,IACN,S,iCCpHP,gBA8B6CG,EAAKR,EAAKM,EA9BnDG,EAA4B,oBAAXC,QAAoD,kBAApBA,OAAOC,SAAwB,SAAUH,GAC5F,cAAcA,GACZ,SAAUA,GACZ,OAAOA,GAAyB,oBAAXE,QAAyBF,EAAII,cAAgBF,QAAUF,IAAQE,OAAOG,UAAY,gBAAkBL,GAGvHM,EAAiB,SAAwBC,EAAUC,GACrD,KAAMD,aAAoBC,GACxB,MAAM,IAAIC,UAAU,sCAIpBC,EAAc,WAChB,SAASC,EAAiBC,EAAQC,GAChC,IAAK,IAAI9D,EAAI,EAAGA,EAAI8D,EAAM/D,OAAQC,IAAK,CACrC,IAAI+D,EAAaD,EAAM9D,GACvB+D,EAAWC,WAAaD,EAAWC,aAAc,EACjDD,EAAWE,cAAe,EACtB,UAAWF,IAAYA,EAAWG,UAAW,GACjD3B,OAAO4B,eAAeN,EAAQE,EAAWtB,IAAKsB,IAIlD,OAAO,SAAUN,EAAaW,EAAYC,GAGxC,OAFID,GAAYR,EAAiBH,EAAYH,UAAWc,GACpDC,GAAaT,EAAiBH,EAAaY,GACxCZ,GAdO,GAiCda,EAA4B,qBAAXnB,OAAyBA,OAAO,kBAfEJ,GAeqD,GAf1DN,EAeyC,mBAf9CQ,EAe0C,IAbnFV,OAAO4B,eAAelB,EAAKR,EAAK,CAC9BM,MAAOA,EACPiB,YAAY,EACZC,cAAc,EACdC,UAAU,IAGZjB,EAAIR,GAAOM,EAGNE,GAILsB,EAAgC,qBAAXpB,OAAyBA,OAAO,eAAiB,iBAE1E,SAASqB,EAAQzB,GACf,QAASA,KAAWA,EAAMwB,GAG5B,SAASE,EAAY1B,GACnB,IAAKA,EAAO,OAAO,EACnB,GAAsE,YAAhD,qBAAVA,EAAwB,YAAcG,EAAQH,IAAsB,OAAO,EACvF,GAAI3C,MAAMC,QAAQ0C,GAAQ,OAAO,EACjC,IAAI2B,EAAQnC,OAAOoC,eAAe5B,GAClC,OAAiB,OAAV2B,GAAkBA,IAAUnC,OAAOe,UAU5C,IAAIsB,EAASrC,OAAOqC,QAAU,SAAgBf,EAAQd,GACpD,IAAK,IAAIN,KAAOM,EACV8B,EAAI9B,EAAON,KACboB,EAAOpB,GAAOM,EAAMN,IAIxB,OAAOoB,GAGT,SAASiB,EAAY/B,GACnB,GAAI3C,MAAMC,QAAQ0C,GAAQ,OAAOA,EAAMgC,QACvC,IAAIlB,OAA6BpC,IAApBsB,EAAMiC,UAA0BzC,OAAO0C,OAAO,MAAQ,GACnE,OAAOL,EAAOf,EAAQd,GAGxB,SAASmC,EAAKnC,EAAOoC,GACnB,GAAI/E,MAAMC,QAAQ0C,GAChB,IAAK,IAAI/C,EAAI,EAAGA,EAAI+C,EAAMhD,OAAQC,IAChCmF,EAAGnF,EAAG+C,EAAM/C,GAAI+C,QAGlB,IAAK,IAAIN,KAAOM,EACdoC,EAAG1C,EAAKM,EAAMN,GAAMM,GAK1B,SAAS8B,EAAIO,EAAOC,GAClB,OAAO9C,OAAOe,UAAUgC,eAAeC,KAAKH,EAAOC,GAGrD,SAASG,EAAGC,EAAGC,GAEb,OAAID,IAAMC,EACK,IAAND,GAAW,EAAIA,IAAM,EAAIC,EAEzBD,IAAMA,GAAKC,IAAMA,EAI5B,SAASC,EAAgBC,EAAOC,EAAUC,EAASC,GACjD3F,MAAMC,QAAQuF,EAAMI,MAGtB,SAA8BJ,EAAOC,EAAUC,EAASC,GAMtD,IALA,IAAIC,EAAOJ,EAAMI,KACbC,EAAOL,EAAMK,KACbC,EAAWN,EAAMM,SACjBC,EAAYC,KAAKC,IAAIL,EAAKjG,OAAQkG,EAAKlG,QAElCC,EAAI,EAAGA,EAAImG,EAAWnG,IAC7B,GAAIkG,EAASlG,IAAMgG,EAAKhG,KAAOiG,EAAKjG,GAAI,CACtC,IAAIsG,EAAOT,EAASnE,OAAO1B,GAC3B8F,EAAQjE,KAAK,CACX0E,GAAI,UACJD,KAAMA,EACNvD,MAAOkD,EAAKjG,KAEd+F,EAAelE,KAAK,CAClB0E,GAAI,UACJD,KAAMA,EACNvD,MAAOiD,EAAKhG,KAMlB,GAAImG,EAAYF,EAAKlG,OAAQ,CAC3B,IAAK,IAAIyG,EAAKL,EAAWK,EAAKP,EAAKlG,OAAQyG,IACzCV,EAAQjE,KAAK,CACX0E,GAAI,MACJD,KAAMT,EAASnE,OAAO8E,GACtBzD,MAAOkD,EAAKO,KAIhBT,EAAelE,KAAK,CAClB0E,GAAI,UACJD,KAAMT,EAASnE,OAAO,UACtBqB,MAAOiD,EAAKjG,cAGX,GAAIoG,EAAYH,EAAKjG,OAAQ,CAC9B+F,EAAQjE,KAAK,CACX0E,GAAI,UACJD,KAAMT,EAASnE,OAAO,UACtBqB,MAAOkD,EAAKlG,SAGd,IAAK,IAAI0G,EAAMN,EAAWM,EAAMT,EAAKjG,OAAQ0G,IAC3CV,EAAelE,KAAK,CAClB0E,GAAI,MACJD,KAAMT,EAASnE,OAAO+E,GACtB1D,MAAOiD,EAAKS,MApDQC,CAAqBd,EAAOC,EAAUC,EAASC,GA0D7E,SAA+BH,EAAOC,EAAUC,EAASC,GACvD,IAAIC,EAAOJ,EAAMI,KACbC,EAAOL,EAAMK,KACjBf,EAAKU,EAAMM,UAAU,SAAUzD,EAAKkE,GAClC,IAAIC,EAAYZ,EAAKvD,GACjBM,EAAQkD,EAAKxD,GACb8D,EAAMI,EAA2BlE,KAAOuD,EAAO,UAAY,MAArC,SAC1B,GAAIY,IAAcZ,GAAe,YAAPO,EAA1B,CACA,IAAID,EAAOT,EAASnE,OAAOe,GAC3BqD,EAAQjE,KAAY,WAAP0E,EAAkB,CAC7BA,GAAIA,EACJD,KAAMA,GACJ,CACFC,GAAIA,EACJD,KAAMA,EACNvD,MAAOA,IAETgD,EAAelE,KAAY,QAAP0E,EAAe,CACjCA,GAAI,SACJD,KAAMA,GACG,WAAPC,EAAkB,CACpBA,GAAI,MACJD,KAAMA,EACNvD,MAAO6D,GACL,CACFL,GAAI,UACJD,KAAMA,EACNvD,MAAO6D,QArFkFC,CAAsBjB,EAAOC,EAAUC,EAASC,GAuI/I,IAAIe,EAAc,GAEdC,EAAS,GAETC,EAAe,WACjB,OAAOD,EAAOA,EAAOhH,OAAS,IAgBhC,SAASkH,EAAYjB,EAAMkB,GACzB,IAAIC,OAAQ,EAEZ,GAAI3C,EAAQwB,GAAO,CACjB,IAAIoB,EAASpB,EAAKzB,GAElB6C,EAAOC,YAAa,EACpBF,EAAQrC,EAAYsC,EAAOD,OAC3BC,EAAOC,YAAa,OAEpBF,EAAQrC,EAAYkB,GAGtBd,EAAKc,GAAM,SAAUX,GACnB9C,OAAO4B,eAAegD,EAAO,GAAK9B,EAmEtC,SAA6BA,GAC3B,OAAOyB,EAAYzB,KAAUyB,EAAYzB,GAAQ,CAC/CpB,cAAc,EACdD,YAAY,EACZsD,IAAK,WACH,OAzCN,SAAc1B,EAAOP,GACnBkC,EAAgB3B,GAChB,IAAI7C,EAAQyE,EAAO5B,GAAOP,GAE1B,IAAKO,EAAMyB,YAActE,IAAU6C,EAAMI,KAAKX,IAASZ,EAAY1B,GAEjE,OADA0E,EAAY7B,GACLA,EAAMK,KAAKZ,GAAQ4B,EAAYlE,EAAO6C,GAG/C,OAAO7C,EAgCI2E,CAAKC,KAAKpD,GAAcc,IAEjCuC,IAAK,SAAgB7E,IA/BzB,SAAc6C,EAAOP,EAAMtC,GAIzB,GAHAwE,EAAgB3B,GAChBA,EAAMM,SAASb,IAAQ,GAElBO,EAAMiC,SAAU,CACnB,GAAIrC,EAAGgC,EAAO5B,GAAOP,GAAOtC,GAAQ,OACpC+E,EAAYlC,GACZ6B,EAAY7B,GAGdA,EAAMK,KAAKZ,GAAQtC,EAsBfgF,CAAKJ,KAAKpD,GAAcc,EAAMtC,MA3EQiF,CAAoB,GAAK3C,OAGnE,IAAIO,EAAQ,CACVqC,MAAOf,EAASA,EAAOe,MAAQjB,IAC/Ba,UAAU,EACVR,YAAY,EAEZa,WAAW,EACXhC,SAAU,GACVgB,OAAQA,EACRlB,KAAMA,EACNmB,MAAOA,EACPlB,KAAM,KACNkC,OAAQA,EACRC,SAAS,GAKX,OAsKF,SAA8BvE,EAAQwB,EAAMtC,GAC1CR,OAAO4B,eAAeN,EAAQwB,EAAM,CAClCtC,MAAOA,EACPiB,YAAY,EACZE,UAAU,IA5KZmE,CAAqBlB,EAAO5C,EAAaqB,GACzCA,EAAMqC,MAAMpG,KAAK+D,GACVuB,EAGT,SAASgB,IACPR,KAAKS,SAAU,EAGjB,SAASZ,EAAO5B,GACd,OAAOA,EAAMK,MAAQL,EAAMI,KA4B7B,SAAS8B,EAAYlC,GACdA,EAAMiC,WACTjC,EAAMiC,UAAW,EACbjC,EAAMsB,QAAQY,EAAYlC,EAAMsB,SAIxC,SAASO,EAAY7B,GACdA,EAAMK,OAAML,EAAMK,KAAOnB,EAAYc,EAAMI,OAgBlD,SAASuB,EAAgB3B,GACvB,IAAsB,IAAlBA,EAAMwC,QAAkB,MAAM,IAAIzH,MAAM,uHAAyH2H,KAAKC,UAAU3C,EAAMK,MAAQL,EAAMI,OAqE1M,SAASwC,EAAiB5C,GAOxB,IANA,IAAII,EAAOJ,EAAMI,KACbmB,EAAQvB,EAAMuB,MAGd3E,EAAOD,OAAOC,KAAK2E,GAEdnH,EAAIwC,EAAKzC,OAAS,EAAGC,GAAK,EAAGA,IAEpC,QAAsByB,IAAlBuE,EAAKxD,EAAKxC,MAAsB6E,EAAImB,EAAMxD,EAAKxC,IACjD,OAAO,EAMX,OAAOwC,EAAKzC,SAAWwC,OAAOC,KAAKwD,GAAMjG,OAG3C,SAAS0I,EAAgB7C,GACvB,IAAIuB,EAAQvB,EAAMuB,MAClB,GAAIA,EAAMpH,SAAW6F,EAAMI,KAAKjG,OAAQ,OAAO,EAQ/C,IAAIgE,EAAaxB,OAAOmG,yBAAyBvB,EAAOA,EAAMpH,OAAS,GAEvE,SAAIgE,GAAeA,EAAWuD,KAahC,IAAIqB,EAAcpG,OAAOqG,OAAO,CAC9B7B,OAAQA,EACRC,aAAcA,EACd6B,aAhOF,SAAsBC,EAAQC,EAAWC,GACvC,IAAIf,EAAQjB,IACZiB,EAAMgB,SAAQ,SAAUrD,GACtB,OAAOA,EAAMyB,YAAa,UAGb5F,IAAXqH,GAAwBA,IAAWC,IACjCC,GAyHR,SAASE,EAAuBC,GAC9B,IAAKA,GAA8E,YAAjD,qBAAXA,EAAyB,YAAcjG,EAAQiG,IAAuB,OAC7F,IAAIvD,EAAQuD,EAAO5E,GACnB,IAAKqB,EAAO,OACZ,IAAII,EAAOJ,EAAMI,KACbmB,EAAQvB,EAAMuB,MACdjB,EAAWN,EAAMM,SAErB,GAAK9F,MAAMC,QAAQ8I,IAoBZ,GAAIV,EAAgB7C,GAAQ,CAIjC,GAHAkC,EAAYlC,GACZM,EAASnG,QAAS,EAEdoH,EAAMpH,OAASiG,EAAKjG,OACtB,IAAK,IAAIC,EAAImH,EAAMpH,OAAQC,EAAIgG,EAAKjG,OAAQC,IAC1CkG,EAASlG,IAAK,OAGhB,IAAK,IAAIwG,EAAKR,EAAKjG,OAAQyG,EAAKW,EAAMpH,OAAQyG,IAC5CN,EAASM,IAAM,EAInB,IAAK,IAAIC,EAAM,EAAGA,EAAMU,EAAMpH,OAAQ0G,SAEdhF,IAAlByE,EAASO,IAAoByC,EAAuB/B,EAAMV,UAlChElE,OAAOC,KAAK2E,GAAO8B,SAAQ,SAAUxG,QAEjBhB,IAAduE,EAAKvD,IAAuBoC,EAAImB,EAAMvD,GAG9ByD,EAASzD,IAEnByG,EAAuB/B,EAAM1E,KAJ7ByD,EAASzD,IAAO,EAChBqF,EAAYlC,OAOhBrD,OAAOC,KAAKwD,GAAMiD,SAAQ,SAAUxG,QAEfhB,IAAf0F,EAAM1E,IAAuBoC,EAAIsC,EAAO1E,KAC1CyD,EAASzD,IAAO,EAChBqF,EAAYlC,OAlJCsD,CAAuBH,GAyG5C,SAA0Bd,GAKxB,IAAK,IAAIjI,EAAIiI,EAAMlI,OAAS,EAAGC,GAAK,EAAGA,IAAK,CAC1C,IAAI4F,EAAQqC,EAAMjI,IAEK,IAAnB4F,EAAMiC,WACJzH,MAAMC,QAAQuF,EAAMI,MAClByC,EAAgB7C,IAAQkC,EAAYlC,GAC/B4C,EAAiB5C,IAAQkC,EAAYlC,KAlHlDwD,CAAiBnB,KAwNnBhB,YAAaA,IAIXoC,EAAW,GAEXC,EAAiB,WACnB,OAAOD,EAASA,EAAStJ,OAAS,IAMpC,SAASwJ,EAAcvD,EAAMkB,GAC3B,IAAItB,EAAQ,CAEVqC,MAAOf,EAASA,EAAOe,MAAQqB,IAE/BzB,UAAU,EAEVK,WAAW,EAEXhC,SAAU,GAEVgB,OAAQA,EAERlB,KAAMA,EAENmB,MAAO,KAEPqC,OAAQ,GAERvD,KAAM,KAENkC,OAAQ,MAGNsB,EAAOrJ,MAAMC,QAAQ2F,GAAQ0D,MAAMC,UAAU,CAAC/D,GAAQgE,GAAcF,MAAMC,UAAU/D,EAAOiE,GAC3F1B,EAASsB,EAAKtB,OACd2B,EAAQL,EAAKK,MAKjB,OAHAlE,EAAMuB,MAAQ2C,EACdlE,EAAMuC,OAASA,EACfvC,EAAMqC,MAAMpG,KAAK+D,GACVkE,EAGT,IAAID,EAAc,CAChBvC,IAqCF,SAAe1B,EAAOP,GACpB,GAAIA,IAASd,EAAa,OAAOqB,EACjC,IAAI4D,EAAS5D,EAAM4D,OAEnB,IAAK5D,EAAMiC,UAAYhD,EAAI2E,EAAQnE,GACjC,OAAOmE,EAAOnE,GAGhB,IAAItC,EAAQgH,EAASnE,GAAOP,GAC5B,GAAIO,EAAMsC,YAAczD,EAAY1B,GAAQ,OAAOA,EAEnD,GAAI6C,EAAMiC,SAAU,CAElB,GAAI9E,IAAU6C,EAAMI,KAAKX,GAAO,OAAOtC,EAEvCyG,EAAS5D,EAAMK,KAGjB,OAAOuD,EAAOnE,GAAQkE,EAAcxG,EAAO6C,IAtD3Cf,IAAK,SAAgBhB,EAAQwB,GAC3B,OAAOA,KAAQ0E,EAASlG,IAE1BmG,QAAS,SAAiBnG,GACxB,OAAOoG,QAAQD,QAAQD,EAASlG,KAElC+D,IAmDF,SAAehC,EAAOP,EAAMtC,GAC1B,IAAK6C,EAAMiC,SAAU,CAKnB,GADkB9E,EAAQyC,EAAGI,EAAMI,KAAKX,GAAOtC,IAAUA,IAAU6C,EAAM4D,OAAOnE,GAAQG,EAAGI,EAAMI,KAAKX,GAAOtC,IAAUsC,KAAQO,EAAMI,KACpH,OAAO,EACxBkE,EAActE,GAKhB,OAFAA,EAAMM,SAASb,IAAQ,EACvBO,EAAMK,KAAKZ,GAAQtC,GACZ,GA9DPoH,eAiEF,SAAwBvE,EAAOP,SAEJ5D,IAArBmE,EAAMI,KAAKX,IAAuBA,KAAQO,EAAMI,QAClDJ,EAAMM,SAASb,IAAQ,EACvB6E,EAActE,IAGZA,EAAMK,aAAaL,EAAMK,KAAKZ,GAClC,OAAO,GAxEPqD,yBA2EF,SAAkC9C,EAAOP,GACvC,IAAI+E,EAAQxE,EAAMiC,SAAWjC,EAAMK,KAAOpB,EAAIe,EAAM4D,OAAQnE,GAAQO,EAAM4D,OAAS5D,EAAMI,KACrFjC,EAAakG,QAAQvB,yBAAyB0B,EAAO/E,IACrDtB,GAAgB3D,MAAMC,QAAQ+J,IAAmB,WAAT/E,IAAoBtB,EAAWE,cAAe,GAC1F,OAAOF,GA9EPI,eAiFF,WACE,MAAM,IAAIxD,MAAM,iEAjFhB0J,eAAgB,WACd,MAAM,IAAI1J,MAAM,gDAGhBiJ,EAAa,GAkBjB,SAASG,EAASnE,GAChB,OAAOA,EAAMK,MAAQL,EAAMI,KA6D7B,SAASkE,EAActE,GAChBA,EAAMiC,WACTjC,EAAMiC,UAAW,EACjBjC,EAAMK,KAAOrB,EAAOE,EAAYc,EAAMI,MAAOJ,EAAM4D,QACnD5D,EAAM4D,OAAS,KACX5D,EAAMsB,QAAQgD,EAActE,EAAMsB,SApF1ChC,EAAK2E,GAAa,SAAUpH,EAAK6H,GAC/BV,EAAWnH,GAAO,WAEhB,OADA1B,UAAU,GAAKA,UAAU,GAAG,GACrBuJ,EAAG9I,MAAMmG,KAAM5G,eAI1B6I,EAAWO,eAAiB,SAAUvE,EAAOP,GAC3C,GAAIkF,MAAMC,SAASnF,IAAQ,MAAM,IAAI1E,MAAM,2DAA6D0E,GACxG,OAAOwE,EAAYM,eAAe5E,KAAKoC,KAAM/B,EAAM,GAAIP,IAGzDuE,EAAWhC,IAAM,SAAUhC,EAAOP,EAAMtC,GACtC,GAAa,WAATsC,GAAqBkF,MAAMC,SAASnF,IAAQ,MAAM,IAAI1E,MAAM,oEAAsE0E,GACtI,OAAOwE,EAAYjC,IAAIrC,KAAKoC,KAAM/B,EAAM,GAAIP,EAAMtC,IA0EpD,IAAI0H,EAAclI,OAAOqG,OAAO,CAC9B7B,OAAQsC,EACRrC,aAAcsC,EACdT,aAhJF,aAiJE5B,YAAasC,IAKf,IAAImB,EAAiB,CACnBC,WAA6B,qBAAVjB,OAA4C,qBAAZO,QACnDW,WAA+B,qBAAZC,GAA0F,mBAJ/G,aAIsGC,KACpGC,SAAU,KACVC,SAAU,KACVC,OAAQ,MA2MNC,EAAQ,IAxMA,WACV,SAASC,EAAMC,GACb7H,EAAeoE,KAAMwD,GACrBvG,EAAO+C,KAAM+C,EAAgBU,GAC7BzD,KAAK0D,cAAc1D,KAAKgD,YACxBhD,KAAK2D,QAAU3D,KAAK2D,QAAQC,KAAK5D,MAgMnC,OA7LAhE,EAAYwH,EAAO,CAAC,CAClB1I,IAAK,UACLM,MAAO,SAAiBiD,EAAMwF,EAAQC,GACpC,IAAIC,EAAQ/D,KAGZ,GAAoB,oBAAT3B,GAAyC,oBAAXwF,EAAuB,CAC9D,IAAIG,EAAcH,EAGlB,OAFAA,EAASxF,EAEF,WACL,IAAK,IAAIlF,EAAOC,UAAUhB,OAAQ6L,EAAOxL,MAAMU,EAAO,EAAIA,EAAO,EAAI,GAAIG,EAAO,EAAGA,EAAOH,EAAMG,IAC9F2K,EAAK3K,EAAO,GAAKF,UAAUE,GAG7B,IAAI+E,EAAOjF,UAAUhB,OAAS,QAAsB0B,IAAjBV,UAAU,GAAmBA,UAAU,GAAK4K,EAC/E,OAAOD,EAAMJ,QAAQtF,GAAM,SAAUmB,GACnC,IAAI0E,EAEJ,OAAQA,EAAUL,GAAQjG,KAAK/D,MAAMqK,EAAS,CAAC1E,EAAOA,GAAOzF,OAAOkK,QAOxE,GAAsB,oBAAXJ,EAAuB,MAAM,IAAI7K,MAAM,4FAClD,QAAsBc,IAAlBgK,GAAwD,oBAAlBA,EAA8B,MAAM,IAAI9K,MAAM,oEAE1F,IAAImI,OAAS,EAEb,GAAKrE,EAAYuB,GAIZ,GAAIxB,EAAQwB,IAEb,QAAevE,KADfqH,EAAS0C,EAAOjG,KAAKS,EAAMA,IACD,OAAOA,MAE9B,CACD2B,KAAKZ,OAAOlF,KAAK,IACjB,IAAIkH,EAAYpB,KAAKV,YAAYjB,GAEjC,IACE8C,EAAS0C,EAAOjG,KAAKwD,EAAWA,GAChCpB,KAAKkB,aAAaC,EAAQC,IAAa0C,GAEvC,IAAI3F,EAAU2F,GAAiB,GAC3B1F,EAAiB0F,GAAiB,GAEtC,QAAehK,IAAXqH,GAAwBA,IAAWC,EACrCD,EAASnB,KAAKmE,SAAS/C,EAAW,GAAIjD,EAASC,OAE5C,CAED,GAAIgD,EAAUxE,GAAasD,SAAU,MAAM,IAAIlH,MAAM,qHAGjD8D,EAAYqE,KAASA,EAASnB,KAAKmE,SAAShD,IAE5C2C,IACF3F,EAAQjE,KAAK,CACX0E,GAAI,UACJD,KAAM,GACNvD,MAAO+F,IAET/C,EAAelE,KAAK,CAClB0E,GAAI,UACJD,KAAM,GACNvD,MAAOiD,MAIf,QACA2B,KAAKX,eAAeiC,SAAQ,SAAUrD,GACpC,OAAOA,EAAMuC,YAEfR,KAAKZ,OAAOzF,MAGdmK,GAAiBA,EAAc3F,EAASC,QA/C5C,QAAetE,KADfqH,EAAS0C,EAAOxF,IACU,OAAOA,EAmDnC,OAAO8C,IAAWxE,OAAU7C,EAAYqH,IAEzC,CACDrG,IAAK,gBACLM,MAAO,SAAuBA,GAC5B4E,KAAKiD,WAAa7H,IAEnB,CACDN,IAAK,gBACLM,MAAO,SAAuBA,GAC5B4E,KAAKgD,WAAa5H,EAClB6B,EAAO+C,KAAM5E,EAAQ0H,EAAc9B,KAQpC,CACDlG,IAAK,WACLM,MAAO,SAAkBoE,EAAOb,EAAMR,EAASC,GAC7C,IAAIH,EAAQuB,EAAM5C,GAElB,IAAKqB,EACH,OAAIrD,OAAOwJ,SAAS5E,GAAeA,EAC5BQ,KAAKqE,aAAa7E,GAI3B,GAAIvB,EAAMqC,QAAUN,KAAKX,eACvB,OAAOG,EAGT,IAAKvB,EAAMiC,SAAU,OAAOjC,EAAMI,KAElC,IAAKJ,EAAMsC,UAAW,CAIpB,GAHAtC,EAAMsC,WAAY,EAClBP,KAAKqE,aAAapG,EAAMuB,MAAOb,EAAMR,EAASC,GAE1C4B,KAAKqD,SAAU,CACjB,IAAI9E,EAAWN,EAAMM,SAErB,IAAK,IAAIb,KAAQa,EACfA,EAASb,IAASsC,KAAKqD,SAASpF,EAAOP,GAIvCsC,KAAKsD,QAAQtD,KAAKsD,OAAOrF,GAGzB+B,KAAKiD,YAAqC,IAAvBjD,KAAKZ,OAAOhH,QACjCwC,OAAOqG,OAAOhD,EAAMK,MAGlBH,GAASH,EAAgBC,EAAOU,EAAMR,EAASC,GAGrD,OAAOH,EAAMK,OAOd,CACDxD,IAAK,eACLM,MAAO,SAAsBkJ,EAAM3F,EAAMR,EAASC,GAChD,IAAImG,EAASvE,KAET/B,EAAQqG,EAAK1H,GAEbqB,IACFqG,EAAOtE,KAAKgD,WAAa/E,EAAMK,KAAOL,EAAMK,KAAOnB,EAAYc,EAAMuB,QAGvE,IAAI4D,EAAWpD,KAAKoD,SA0BpB,OADA7F,EAAK+G,GAvBkB,SAASE,EAAiB9G,EAAMtC,EAAOmE,GAE5D,IAAIkF,IAAYxG,GAASsB,IAAW+E,EAEpC,GAAIzH,EAAQzB,IAKV,GAHAmE,EAAO7B,GAAQtC,EACf+C,GAAWsG,IAAYxG,EAAMM,SAASb,GAAQ6G,EAAOJ,SAAS/I,EAAOuD,EAAK5E,OAAO2D,GAAOS,EAASC,GAAkBmG,EAAOJ,SAAS/I,GAE/HqJ,GAAWrJ,IAAU6C,EAAMI,KAAKX,GAAO,WAExC,IAAI+G,GAAW5G,EAAGzC,EAAO6C,EAAMI,KAAKX,IACrC,OAEOZ,EAAY1B,KAAWR,OAAOwJ,SAAShJ,IAC5CmC,EAAKnC,EAAOoJ,GAGdC,GAAWrB,GACbA,EAASnF,EAAOP,EAAMtC,MAKnBkJ,MAGJd,EArMG,IA6NRG,EAAUJ,EAAMI,QA4BCA,GAxrBrB,SAAsBnE,EAAOrB,GAC3B,IAAK,IAAI9F,EAAI,EAAGA,EAAI8F,EAAQ/F,OAAQC,IAAK,CACvC,IAAIqM,EAAQvG,EAAQ9F,GAChBsG,EAAO+F,EAAM/F,KAEjB,GAAoB,IAAhBA,EAAKvG,QAA6B,YAAbsM,EAAM9F,GAC7BY,EAAQkF,EAAMtJ,UACT,CAGL,IAFA,IAAIiD,EAAOmB,EAEFmF,EAAM,EAAGA,EAAMhG,EAAKvG,OAAS,EAAGuM,IAEvC,KADAtG,EAAOA,EAAKM,EAAKgG,MAC4D,YAA/C,qBAATtG,EAAuB,YAAc9C,EAAQ8C,IAAqB,MAAM,IAAIrF,MAAM,6CAA+C2F,EAAK5F,KAAK,MAGlK,IAAI+B,EAAM6D,EAAKA,EAAKvG,OAAS,GAE7B,OAAQsM,EAAM9F,IACZ,IAAK,UACL,IAAK,MAEHP,EAAKvD,GAAO4J,EAAMtJ,MAClB,MAEF,IAAK,SACH,GAAI3C,MAAMC,QAAQ2F,GAAO,CACvB,GAAIvD,IAAQuD,EAAKjG,OAAS,EAAG,MAAM,IAAIY,MAAM,0DAA4D8B,EAAM,aAAeuD,EAAKjG,QAEnIiG,EAAKjG,QAAU,cAERiG,EAAKvD,GAGd,MAEF,QACE,MAAM,IAAI9B,MAAM,gCAAkC0L,EAAM9F,MAKhE,OAAOY,KAipBM,Q","file":"static/js/1.b13cf126.chunk.js","sourcesContent":["function defaultEqualityCheck(a, b) {\n  return a === b;\n}\n\nfunction areArgumentsShallowlyEqual(equalityCheck, prev, next) {\n  if (prev === null || next === null || prev.length !== next.length) {\n    return false;\n  } // Do this in a for loop (and not a `forEach` or an `every`) so we can determine equality as fast as possible.\n\n\n  var length = prev.length;\n\n  for (var i = 0; i < length; i++) {\n    if (!equalityCheck(prev[i], next[i])) {\n      return false;\n    }\n  }\n\n  return true;\n}\n\nexport function defaultMemoize(func) {\n  var equalityCheck = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : defaultEqualityCheck;\n  var lastArgs = null;\n  var lastResult = null; // we reference arguments instead of spreading them for performance reasons\n\n  return function () {\n    if (!areArgumentsShallowlyEqual(equalityCheck, lastArgs, arguments)) {\n      // apply arguments instead of spreading for performance.\n      lastResult = func.apply(null, arguments);\n    }\n\n    lastArgs = arguments;\n    return lastResult;\n  };\n}\n\nfunction getDependencies(funcs) {\n  var dependencies = Array.isArray(funcs[0]) ? funcs[0] : funcs;\n\n  if (!dependencies.every(function (dep) {\n    return typeof dep === 'function';\n  })) {\n    var dependencyTypes = dependencies.map(function (dep) {\n      return typeof dep;\n    }).join(', ');\n    throw new Error('Selector creators expect all input-selectors to be functions, ' + ('instead received the following types: [' + dependencyTypes + ']'));\n  }\n\n  return dependencies;\n}\n\nexport function createSelectorCreator(memoize) {\n  for (var _len = arguments.length, memoizeOptions = Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {\n    memoizeOptions[_key - 1] = arguments[_key];\n  }\n\n  return function () {\n    for (var _len2 = arguments.length, funcs = Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {\n      funcs[_key2] = arguments[_key2];\n    }\n\n    var recomputations = 0;\n    var resultFunc = funcs.pop();\n    var dependencies = getDependencies(funcs);\n    var memoizedResultFunc = memoize.apply(undefined, [function () {\n      recomputations++; // apply arguments instead of spreading for performance.\n\n      return resultFunc.apply(null, arguments);\n    }].concat(memoizeOptions)); // If a selector is called with the exact same arguments we don't need to traverse our dependencies again.\n\n    var selector = memoize(function () {\n      var params = [];\n      var length = dependencies.length;\n\n      for (var i = 0; i < length; i++) {\n        // apply arguments instead of spreading and mutate a local list of params for performance.\n        params.push(dependencies[i].apply(null, arguments));\n      } // apply arguments instead of spreading for performance.\n\n\n      return memoizedResultFunc.apply(null, params);\n    });\n    selector.resultFunc = resultFunc;\n    selector.dependencies = dependencies;\n\n    selector.recomputations = function () {\n      return recomputations;\n    };\n\n    selector.resetRecomputations = function () {\n      return recomputations = 0;\n    };\n\n    return selector;\n  };\n}\nexport var createSelector = createSelectorCreator(defaultMemoize);\nexport function createStructuredSelector(selectors) {\n  var selectorCreator = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : createSelector;\n\n  if (typeof selectors !== 'object') {\n    throw new Error('createStructuredSelector expects first argument to be an object ' + ('where each property is a selector, instead received a ' + typeof selectors));\n  }\n\n  var objectKeys = Object.keys(selectors);\n  return selectorCreator(objectKeys.map(function (key) {\n    return selectors[key];\n  }), function () {\n    for (var _len3 = arguments.length, values = Array(_len3), _key3 = 0; _key3 < _len3; _key3++) {\n      values[_key3] = arguments[_key3];\n    }\n\n    return values.reduce(function (composition, value, index) {\n      composition[objectKeys[index]] = value;\n      return composition;\n    }, {});\n  });\n}","var _typeof = typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\" ? function (obj) {\n  return typeof obj;\n} : function (obj) {\n  return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj;\n};\n\nvar classCallCheck = function classCallCheck(instance, Constructor) {\n  if (!(instance instanceof Constructor)) {\n    throw new TypeError(\"Cannot call a class as a function\");\n  }\n};\n\nvar createClass = function () {\n  function defineProperties(target, props) {\n    for (var i = 0; i < props.length; i++) {\n      var descriptor = props[i];\n      descriptor.enumerable = descriptor.enumerable || false;\n      descriptor.configurable = true;\n      if (\"value\" in descriptor) descriptor.writable = true;\n      Object.defineProperty(target, descriptor.key, descriptor);\n    }\n  }\n\n  return function (Constructor, protoProps, staticProps) {\n    if (protoProps) defineProperties(Constructor.prototype, protoProps);\n    if (staticProps) defineProperties(Constructor, staticProps);\n    return Constructor;\n  };\n}();\n\nvar defineProperty = function defineProperty(obj, key, value) {\n  if (key in obj) {\n    Object.defineProperty(obj, key, {\n      value: value,\n      enumerable: true,\n      configurable: true,\n      writable: true\n    });\n  } else {\n    obj[key] = value;\n  }\n\n  return obj;\n};\n\nvar NOTHING = typeof Symbol !== \"undefined\" ? Symbol(\"immer-nothing\") : defineProperty({}, \"immer-nothing\", true);\nvar DRAFT_STATE = typeof Symbol !== \"undefined\" ? Symbol(\"immer-state\") : \"__$immer_state\";\n\nfunction isDraft(value) {\n  return !!value && !!value[DRAFT_STATE];\n}\n\nfunction isDraftable(value) {\n  if (!value) return false;\n  if ((typeof value === \"undefined\" ? \"undefined\" : _typeof(value)) !== \"object\") return false;\n  if (Array.isArray(value)) return true;\n  var proto = Object.getPrototypeOf(value);\n  return proto === null || proto === Object.prototype;\n}\n\nfunction original(value) {\n  if (value && value[DRAFT_STATE]) {\n    return value[DRAFT_STATE].base;\n  } // otherwise return undefined\n\n}\n\nvar assign = Object.assign || function assign(target, value) {\n  for (var key in value) {\n    if (has(value, key)) {\n      target[key] = value[key];\n    }\n  }\n\n  return target;\n};\n\nfunction shallowCopy(value) {\n  if (Array.isArray(value)) return value.slice();\n  var target = value.__proto__ === undefined ? Object.create(null) : {};\n  return assign(target, value);\n}\n\nfunction each(value, cb) {\n  if (Array.isArray(value)) {\n    for (var i = 0; i < value.length; i++) {\n      cb(i, value[i], value);\n    }\n  } else {\n    for (var key in value) {\n      cb(key, value[key], value);\n    }\n  }\n}\n\nfunction has(thing, prop) {\n  return Object.prototype.hasOwnProperty.call(thing, prop);\n}\n\nfunction is(x, y) {\n  // From: https://github.com/facebook/fbjs/blob/c69904a511b900266935168223063dd8772dfc40/packages/fbjs/src/core/shallowEqual.js\n  if (x === y) {\n    return x !== 0 || 1 / x === 1 / y;\n  } else {\n    return x !== x && y !== y;\n  }\n}\n\nfunction generatePatches(state, basePath, patches, inversePatches) {\n  Array.isArray(state.base) ? generateArrayPatches(state, basePath, patches, inversePatches) : generateObjectPatches(state, basePath, patches, inversePatches);\n}\n\nfunction generateArrayPatches(state, basePath, patches, inversePatches) {\n  var base = state.base,\n      copy = state.copy,\n      assigned = state.assigned;\n  var minLength = Math.min(base.length, copy.length); // Look for replaced indices.\n\n  for (var i = 0; i < minLength; i++) {\n    if (assigned[i] && base[i] !== copy[i]) {\n      var path = basePath.concat(i);\n      patches.push({\n        op: \"replace\",\n        path: path,\n        value: copy[i]\n      });\n      inversePatches.push({\n        op: \"replace\",\n        path: path,\n        value: base[i]\n      });\n    }\n  } // Did the array expand?\n\n\n  if (minLength < copy.length) {\n    for (var _i = minLength; _i < copy.length; _i++) {\n      patches.push({\n        op: \"add\",\n        path: basePath.concat(_i),\n        value: copy[_i]\n      });\n    }\n\n    inversePatches.push({\n      op: \"replace\",\n      path: basePath.concat(\"length\"),\n      value: base.length\n    });\n  } // ...or did it shrink?\n  else if (minLength < base.length) {\n      patches.push({\n        op: \"replace\",\n        path: basePath.concat(\"length\"),\n        value: copy.length\n      });\n\n      for (var _i2 = minLength; _i2 < base.length; _i2++) {\n        inversePatches.push({\n          op: \"add\",\n          path: basePath.concat(_i2),\n          value: base[_i2]\n        });\n      }\n    }\n}\n\nfunction generateObjectPatches(state, basePath, patches, inversePatches) {\n  var base = state.base,\n      copy = state.copy;\n  each(state.assigned, function (key, assignedValue) {\n    var origValue = base[key];\n    var value = copy[key];\n    var op = !assignedValue ? \"remove\" : key in base ? \"replace\" : \"add\";\n    if (origValue === base && op === \"replace\") return;\n    var path = basePath.concat(key);\n    patches.push(op === \"remove\" ? {\n      op: op,\n      path: path\n    } : {\n      op: op,\n      path: path,\n      value: value\n    });\n    inversePatches.push(op === \"add\" ? {\n      op: \"remove\",\n      path: path\n    } : op === \"remove\" ? {\n      op: \"add\",\n      path: path,\n      value: origValue\n    } : {\n      op: \"replace\",\n      path: path,\n      value: origValue\n    });\n  });\n}\n\nfunction applyPatches(draft, patches) {\n  for (var i = 0; i < patches.length; i++) {\n    var patch = patches[i];\n    var path = patch.path;\n\n    if (path.length === 0 && patch.op === \"replace\") {\n      draft = patch.value;\n    } else {\n      var base = draft;\n\n      for (var _i3 = 0; _i3 < path.length - 1; _i3++) {\n        base = base[path[_i3]];\n        if (!base || (typeof base === \"undefined\" ? \"undefined\" : _typeof(base)) !== \"object\") throw new Error(\"Cannot apply patch, path doesn't resolve: \" + path.join(\"/\")); // prettier-ignore\n      }\n\n      var key = path[path.length - 1];\n\n      switch (patch.op) {\n        case \"replace\":\n        case \"add\":\n          // TODO: add support is not extensive, it does not support insertion or `-` atm!\n          base[key] = patch.value;\n          break;\n\n        case \"remove\":\n          if (Array.isArray(base)) {\n            if (key !== base.length - 1) throw new Error(\"Only the last index of an array can be removed, index: \" + key + \", length: \" + base.length); // prettier-ignore\n\n            base.length -= 1;\n          } else {\n            delete base[key];\n          }\n\n          break;\n\n        default:\n          throw new Error(\"Unsupported patch operation: \" + patch.op);\n      }\n    }\n  }\n\n  return draft;\n} // @ts-check\n\n\nvar descriptors = {}; // For nested produce calls:\n\nvar scopes = [];\n\nvar currentScope = function currentScope() {\n  return scopes[scopes.length - 1];\n};\n\nfunction willFinalize(result, baseDraft, needPatches) {\n  var scope = currentScope();\n  scope.forEach(function (state) {\n    return state.finalizing = true;\n  });\n\n  if (result === undefined || result === baseDraft) {\n    if (needPatches) markChangesRecursively(baseDraft); // This is faster when we don't care about which attributes changed.\n\n    markChangesSweep(scope);\n  }\n}\n\nfunction createDraft(base, parent) {\n  var draft = void 0;\n\n  if (isDraft(base)) {\n    var _state = base[DRAFT_STATE]; // Avoid creating new drafts when copying.\n\n    _state.finalizing = true;\n    draft = shallowCopy(_state.draft);\n    _state.finalizing = false;\n  } else {\n    draft = shallowCopy(base);\n  }\n\n  each(base, function (prop) {\n    Object.defineProperty(draft, \"\" + prop, createPropertyProxy(\"\" + prop));\n  }); // See \"proxy.js\" for property documentation.\n\n  var state = {\n    scope: parent ? parent.scope : currentScope(),\n    modified: false,\n    finalizing: false,\n    // es5 only\n    finalized: false,\n    assigned: {},\n    parent: parent,\n    base: base,\n    draft: draft,\n    copy: null,\n    revoke: revoke,\n    revoked: false // es5 only\n\n  };\n  createHiddenProperty(draft, DRAFT_STATE, state);\n  state.scope.push(state);\n  return draft;\n}\n\nfunction revoke() {\n  this.revoked = true;\n}\n\nfunction source(state) {\n  return state.copy || state.base;\n}\n\nfunction _get(state, prop) {\n  assertUnrevoked(state);\n  var value = source(state)[prop]; // Drafts are only created for proxyable values that exist in the base state.\n\n  if (!state.finalizing && value === state.base[prop] && isDraftable(value)) {\n    prepareCopy(state);\n    return state.copy[prop] = createDraft(value, state);\n  }\n\n  return value;\n}\n\nfunction _set(state, prop, value) {\n  assertUnrevoked(state);\n  state.assigned[prop] = true;\n\n  if (!state.modified) {\n    if (is(source(state)[prop], value)) return;\n    markChanged(state);\n    prepareCopy(state);\n  }\n\n  state.copy[prop] = value;\n}\n\nfunction markChanged(state) {\n  if (!state.modified) {\n    state.modified = true;\n    if (state.parent) markChanged(state.parent);\n  }\n}\n\nfunction prepareCopy(state) {\n  if (!state.copy) state.copy = shallowCopy(state.base);\n}\n\nfunction createPropertyProxy(prop) {\n  return descriptors[prop] || (descriptors[prop] = {\n    configurable: true,\n    enumerable: true,\n    get: function get$$1() {\n      return _get(this[DRAFT_STATE], prop);\n    },\n    set: function set$$1(value) {\n      _set(this[DRAFT_STATE], prop, value);\n    }\n  });\n}\n\nfunction assertUnrevoked(state) {\n  if (state.revoked === true) throw new Error(\"Cannot use a proxy that has been revoked. Did you pass an object from inside an immer function to an async process? \" + JSON.stringify(state.copy || state.base));\n} // This looks expensive, but only proxies are visited, and only objects without known changes are scanned.\n\n\nfunction markChangesSweep(scope) {\n  // The natural order of drafts in the `scope` array is based on when they\n  // were accessed. By processing drafts in reverse natural order, we have a\n  // better chance of processing leaf nodes first. When a leaf node is known to\n  // have changed, we can avoid any traversal of its ancestor nodes.\n  for (var i = scope.length - 1; i >= 0; i--) {\n    var state = scope[i];\n\n    if (state.modified === false) {\n      if (Array.isArray(state.base)) {\n        if (hasArrayChanges(state)) markChanged(state);\n      } else if (hasObjectChanges(state)) markChanged(state);\n    }\n  }\n}\n\nfunction markChangesRecursively(object) {\n  if (!object || (typeof object === \"undefined\" ? \"undefined\" : _typeof(object)) !== \"object\") return;\n  var state = object[DRAFT_STATE];\n  if (!state) return;\n  var base = state.base,\n      draft = state.draft,\n      assigned = state.assigned;\n\n  if (!Array.isArray(object)) {\n    // Look for added keys.\n    Object.keys(draft).forEach(function (key) {\n      // The `undefined` check is a fast path for pre-existing keys.\n      if (base[key] === undefined && !has(base, key)) {\n        assigned[key] = true;\n        markChanged(state);\n      } else if (!assigned[key]) {\n        // Only untouched properties trigger recursion.\n        markChangesRecursively(draft[key]);\n      }\n    }); // Look for removed keys.\n\n    Object.keys(base).forEach(function (key) {\n      // The `undefined` check is a fast path for pre-existing keys.\n      if (draft[key] === undefined && !has(draft, key)) {\n        assigned[key] = false;\n        markChanged(state);\n      }\n    });\n  } else if (hasArrayChanges(state)) {\n    markChanged(state);\n    assigned.length = true;\n\n    if (draft.length < base.length) {\n      for (var i = draft.length; i < base.length; i++) {\n        assigned[i] = false;\n      }\n    } else {\n      for (var _i = base.length; _i < draft.length; _i++) {\n        assigned[_i] = true;\n      }\n    }\n\n    for (var _i2 = 0; _i2 < draft.length; _i2++) {\n      // Only untouched indices trigger recursion.\n      if (assigned[_i2] === undefined) markChangesRecursively(draft[_i2]);\n    }\n  }\n}\n\nfunction hasObjectChanges(state) {\n  var base = state.base,\n      draft = state.draft; // Search for added keys. Start at the back, because non-numeric keys\n  // are ordered by time of definition on the object.\n\n  var keys = Object.keys(draft);\n\n  for (var i = keys.length - 1; i >= 0; i--) {\n    // The `undefined` check is a fast path for pre-existing keys.\n    if (base[keys[i]] === undefined && !has(base, keys[i])) {\n      return true;\n    }\n  } // Since no keys have been added, we can compare lengths to know if an\n  // object has been deleted.\n\n\n  return keys.length !== Object.keys(base).length;\n}\n\nfunction hasArrayChanges(state) {\n  var draft = state.draft;\n  if (draft.length !== state.base.length) return true; // See #116\n  // If we first shorten the length, our array interceptors will be removed.\n  // If after that new items are added, result in the same original length,\n  // those last items will have no intercepting property.\n  // So if there is no own descriptor on the last position, we know that items were removed and added\n  // N.B.: splice, unshift, etc only shift values around, but not prop descriptors, so we only have to check\n  // the last one\n\n  var descriptor = Object.getOwnPropertyDescriptor(draft, draft.length - 1); // descriptor can be null, but only for newly created sparse arrays, eg. new Array(10)\n\n  if (descriptor && !descriptor.get) return true; // For all other cases, we don't have to compare, as they would have been picked up by the index setters\n\n  return false;\n}\n\nfunction createHiddenProperty(target, prop, value) {\n  Object.defineProperty(target, prop, {\n    value: value,\n    enumerable: false,\n    writable: true\n  });\n}\n\nvar legacyProxy = Object.freeze({\n  scopes: scopes,\n  currentScope: currentScope,\n  willFinalize: willFinalize,\n  createDraft: createDraft\n}); // @ts-check\n// For nested produce calls:\n\nvar scopes$1 = [];\n\nvar currentScope$1 = function currentScope() {\n  return scopes$1[scopes$1.length - 1];\n}; // Do nothing before being finalized.\n\n\nfunction willFinalize$1() {}\n\nfunction createDraft$1(base, parent) {\n  var state = {\n    // Track which produce call this is associated with.\n    scope: parent ? parent.scope : currentScope$1(),\n    // True for both shallow and deep changes.\n    modified: false,\n    // Used during finalization.\n    finalized: false,\n    // Track which properties have been assigned (true) or deleted (false).\n    assigned: {},\n    // The parent draft state.\n    parent: parent,\n    // The base state.\n    base: base,\n    // The base proxy.\n    draft: null,\n    // Any property proxies.\n    drafts: {},\n    // The base copy with any updated values.\n    copy: null,\n    // Called by the `produce` function.\n    revoke: null\n  };\n\n  var _ref = Array.isArray(base) ? Proxy.revocable([state], arrayTraps) : Proxy.revocable(state, objectTraps),\n      revoke = _ref.revoke,\n      proxy = _ref.proxy;\n\n  state.draft = proxy;\n  state.revoke = revoke;\n  state.scope.push(state);\n  return proxy;\n}\n\nvar objectTraps = {\n  get: get$1,\n  has: function has$$1(target, prop) {\n    return prop in source$1(target);\n  },\n  ownKeys: function ownKeys(target) {\n    return Reflect.ownKeys(source$1(target));\n  },\n  set: set$1,\n  deleteProperty: deleteProperty,\n  getOwnPropertyDescriptor: getOwnPropertyDescriptor,\n  defineProperty: defineProperty$1,\n  setPrototypeOf: function setPrototypeOf() {\n    throw new Error(\"Immer does not support `setPrototypeOf()`.\");\n  }\n};\nvar arrayTraps = {};\neach(objectTraps, function (key, fn) {\n  arrayTraps[key] = function () {\n    arguments[0] = arguments[0][0];\n    return fn.apply(this, arguments);\n  };\n});\n\narrayTraps.deleteProperty = function (state, prop) {\n  if (isNaN(parseInt(prop))) throw new Error(\"Immer does not support deleting properties from arrays: \" + prop);\n  return objectTraps.deleteProperty.call(this, state[0], prop);\n};\n\narrayTraps.set = function (state, prop, value) {\n  if (prop !== \"length\" && isNaN(parseInt(prop))) throw new Error(\"Immer does not support setting non-numeric properties on arrays: \" + prop);\n  return objectTraps.set.call(this, state[0], prop, value);\n};\n\nfunction source$1(state) {\n  return state.copy || state.base;\n}\n\nfunction get$1(state, prop) {\n  if (prop === DRAFT_STATE) return state;\n  var drafts = state.drafts; // Check for existing draft in unmodified state.\n\n  if (!state.modified && has(drafts, prop)) {\n    return drafts[prop];\n  }\n\n  var value = source$1(state)[prop];\n  if (state.finalized || !isDraftable(value)) return value; // Check for existing draft in modified state.\n\n  if (state.modified) {\n    // Assigned values are never drafted. This catches any drafts we created, too.\n    if (value !== state.base[prop]) return value; // Store drafts on the copy (when one exists).\n\n    drafts = state.copy;\n  }\n\n  return drafts[prop] = createDraft$1(value, state);\n}\n\nfunction set$1(state, prop, value) {\n  if (!state.modified) {\n    // Optimize based on value's truthiness. Truthy values are guaranteed to\n    // never be undefined, so we can avoid the `in` operator. Lastly, truthy\n    // values may be drafts, but falsy values are never drafts.\n    var isUnchanged = value ? is(state.base[prop], value) || value === state.drafts[prop] : is(state.base[prop], value) && prop in state.base;\n    if (isUnchanged) return true;\n    markChanged$1(state);\n  }\n\n  state.assigned[prop] = true;\n  state.copy[prop] = value;\n  return true;\n}\n\nfunction deleteProperty(state, prop) {\n  // The `undefined` check is a fast path for pre-existing keys.\n  if (state.base[prop] !== undefined || prop in state.base) {\n    state.assigned[prop] = false;\n    markChanged$1(state);\n  }\n\n  if (state.copy) delete state.copy[prop];\n  return true;\n}\n\nfunction getOwnPropertyDescriptor(state, prop) {\n  var owner = state.modified ? state.copy : has(state.drafts, prop) ? state.drafts : state.base;\n  var descriptor = Reflect.getOwnPropertyDescriptor(owner, prop);\n  if (descriptor && !(Array.isArray(owner) && prop === \"length\")) descriptor.configurable = true;\n  return descriptor;\n}\n\nfunction defineProperty$1() {\n  throw new Error(\"Immer does not support defining properties on draft objects.\");\n}\n\nfunction markChanged$1(state) {\n  if (!state.modified) {\n    state.modified = true;\n    state.copy = assign(shallowCopy(state.base), state.drafts);\n    state.drafts = null;\n    if (state.parent) markChanged$1(state.parent);\n  }\n}\n\nvar modernProxy = Object.freeze({\n  scopes: scopes$1,\n  currentScope: currentScope$1,\n  willFinalize: willFinalize$1,\n  createDraft: createDraft$1\n});\n\nfunction verifyMinified() {}\n\nvar configDefaults = {\n  useProxies: typeof Proxy !== \"undefined\" && typeof Reflect !== \"undefined\",\n  autoFreeze: typeof process !== \"undefined\" ? process.env.NODE_ENV !== \"production\" : verifyMinified.name === \"verifyMinified\",\n  onAssign: null,\n  onDelete: null,\n  onCopy: null\n};\n\nvar Immer = function () {\n  function Immer(config) {\n    classCallCheck(this, Immer);\n    assign(this, configDefaults, config);\n    this.setUseProxies(this.useProxies);\n    this.produce = this.produce.bind(this);\n  }\n\n  createClass(Immer, [{\n    key: \"produce\",\n    value: function produce(base, recipe, patchListener) {\n      var _this = this; // curried invocation\n\n\n      if (typeof base === \"function\" && typeof recipe !== \"function\") {\n        var defaultBase = recipe;\n        recipe = base; // prettier-ignore\n\n        return function () {\n          for (var _len = arguments.length, args = Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {\n            args[_key - 1] = arguments[_key];\n          }\n\n          var base = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : defaultBase;\n          return _this.produce(base, function (draft) {\n            var _recipe;\n\n            return (_recipe = recipe).call.apply(_recipe, [draft, draft].concat(args));\n          });\n        };\n      } // prettier-ignore\n\n\n      {\n        if (typeof recipe !== \"function\") throw new Error(\"if first argument is not a function, the second argument to produce should be a function\");\n        if (patchListener !== undefined && typeof patchListener !== \"function\") throw new Error(\"the third argument of a producer should not be set or a function\");\n      }\n      var result = void 0; // Only create proxies for plain objects/arrays.\n\n      if (!isDraftable(base)) {\n        result = recipe(base);\n        if (result === undefined) return base;\n      } // See #100, don't nest producers\n      else if (isDraft(base)) {\n          result = recipe.call(base, base);\n          if (result === undefined) return base;\n        } // The given value must be proxied.\n        else {\n            this.scopes.push([]);\n            var baseDraft = this.createDraft(base);\n\n            try {\n              result = recipe.call(baseDraft, baseDraft);\n              this.willFinalize(result, baseDraft, !!patchListener); // Never generate patches when no listener exists.\n\n              var patches = patchListener && [],\n                  inversePatches = patchListener && []; // Finalize the modified draft...\n\n              if (result === undefined || result === baseDraft) {\n                result = this.finalize(baseDraft, [], patches, inversePatches);\n              } // ...or use a replacement value.\n              else {\n                  // Users must never modify the draft _and_ return something else.\n                  if (baseDraft[DRAFT_STATE].modified) throw new Error(\"An immer producer returned a new value *and* modified its draft. Either return a new value *or* modify the draft.\"); // prettier-ignore\n                  // Finalize the replacement in case it contains (or is) a subset of the draft.\n\n                  if (isDraftable(result)) result = this.finalize(result);\n\n                  if (patchListener) {\n                    patches.push({\n                      op: \"replace\",\n                      path: [],\n                      value: result\n                    });\n                    inversePatches.push({\n                      op: \"replace\",\n                      path: [],\n                      value: base\n                    });\n                  }\n                }\n            } finally {\n              this.currentScope().forEach(function (state) {\n                return state.revoke();\n              });\n              this.scopes.pop();\n            }\n\n            patchListener && patchListener(patches, inversePatches);\n          } // Normalize the result.\n\n\n      return result === NOTHING ? undefined : result;\n    }\n  }, {\n    key: \"setAutoFreeze\",\n    value: function setAutoFreeze(value) {\n      this.autoFreeze = value;\n    }\n  }, {\n    key: \"setUseProxies\",\n    value: function setUseProxies(value) {\n      this.useProxies = value;\n      assign(this, value ? modernProxy : legacyProxy);\n    }\n    /**\n     * @internal\n     * Finalize a draft, returning either the unmodified base state or a modified\n     * copy of the base state.\n     */\n\n  }, {\n    key: \"finalize\",\n    value: function finalize(draft, path, patches, inversePatches) {\n      var state = draft[DRAFT_STATE];\n\n      if (!state) {\n        if (Object.isFrozen(draft)) return draft;\n        return this.finalizeTree(draft);\n      } // Never finalize drafts owned by an outer scope.\n\n\n      if (state.scope !== this.currentScope()) {\n        return draft;\n      }\n\n      if (!state.modified) return state.base;\n\n      if (!state.finalized) {\n        state.finalized = true;\n        this.finalizeTree(state.draft, path, patches, inversePatches);\n\n        if (this.onDelete) {\n          var assigned = state.assigned;\n\n          for (var prop in assigned) {\n            assigned[prop] || this.onDelete(state, prop);\n          }\n        }\n\n        if (this.onCopy) this.onCopy(state); // Nested producers must never auto-freeze their result,\n        // because it may contain drafts from parent producers.\n\n        if (this.autoFreeze && this.scopes.length === 1) {\n          Object.freeze(state.copy);\n        }\n\n        if (patches) generatePatches(state, path, patches, inversePatches);\n      }\n\n      return state.copy;\n    }\n    /**\n     * @internal\n     * Finalize all drafts in the given state tree.\n     */\n\n  }, {\n    key: \"finalizeTree\",\n    value: function finalizeTree(root, path, patches, inversePatches) {\n      var _this2 = this;\n\n      var state = root[DRAFT_STATE];\n\n      if (state) {\n        root = this.useProxies ? state.copy : state.copy = shallowCopy(state.draft);\n      }\n\n      var onAssign = this.onAssign;\n\n      var finalizeProperty = function finalizeProperty(prop, value, parent) {\n        // Only `root` can be a draft in here.\n        var inDraft = !!state && parent === root;\n\n        if (isDraft(value)) {\n          // prettier-ignore\n          parent[prop] = value = // Patches are never generated for assigned properties.\n          patches && inDraft && !state.assigned[prop] ? _this2.finalize(value, path.concat(prop), patches, inversePatches) : _this2.finalize(value); // Unchanged drafts are ignored.\n\n          if (inDraft && value === state.base[prop]) return;\n        } // Unchanged draft properties are ignored.\n        else if (inDraft && is(value, state.base[prop])) {\n            return;\n          } // Search new objects for unfinalized drafts. Frozen objects should never contain drafts.\n          else if (isDraftable(value) && !Object.isFrozen(value)) {\n              each(value, finalizeProperty);\n            }\n\n        if (inDraft && onAssign) {\n          onAssign(state, prop, value);\n        }\n      };\n\n      each(root, finalizeProperty);\n      return root;\n    }\n  }]);\n  return Immer;\n}();\n\nvar immer = new Immer();\n/**\n * The `produce` function takes a value and a \"recipe function\" (whose\n * return value often depends on the base state). The recipe function is\n * free to mutate its first argument however it wants. All mutations are\n * only ever applied to a __copy__ of the base state.\n *\n * Pass only a function to create a \"curried producer\" which relieves you\n * from passing the recipe function every time.\n *\n * Only plain objects and arrays are made mutable. All other objects are\n * considered uncopyable.\n *\n * Note: This function is __bound__ to its `Immer` instance.\n *\n * @param {any} base - the initial state\n * @param {Function} producer - function that receives a proxy of the base state as first argument and which can be freely modified\n * @param {Function} patchListener - optional function that will be called with all the patches produced here\n * @returns {any} a new state, or the initial state if nothing was modified\n */\n\nvar produce = immer.produce;\n/**\n * Pass true to automatically freeze all copies created by Immer.\n *\n * By default, auto-freezing is disabled in production.\n */\n\nvar setAutoFreeze = function setAutoFreeze(value) {\n  return immer.setAutoFreeze(value);\n};\n/**\n * Pass true to use the ES2015 `Proxy` class when creating drafts, which is\n * always faster than using ES5 proxies.\n *\n * By default, feature detection is used, so calling this is rarely necessary.\n */\n\n\nvar setUseProxies = function setUseProxies(value) {\n  return immer.setUseProxies(value);\n};\n/**\n * Apply an array of Immer patches to the first argument.\n *\n * This function is a producer, which means copy-on-write is in effect.\n */\n\n\nvar applyPatches$1 = produce(applyPatches);\nexport { produce, setAutoFreeze, setUseProxies, applyPatches$1 as applyPatches, Immer, original, isDraft, NOTHING as nothing };\nexport default produce;"],"sourceRoot":""}